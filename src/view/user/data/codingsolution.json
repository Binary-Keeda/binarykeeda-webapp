[
  {
    "topicName": "Bit Manipulation and Number Theory",
    "problems": [
      {
        "title": "Sieve of Eratosthenes",
        "description": "Given an integer num, return the number of prime numbers that are strictly less than num.\n\n**Example:**\n- Input: num = 11\n- Output: 4 (because the prime numbers strictly less than 11 are – 2, 3, 5, 7)",
        "algorithm": "**Algorithm: Sieve of Eratosthenes**\n\n**Input:** An integer n\n**Output:** The number of prime numbers less than n\n\n1. **Initialization:**\n   - Create a boolean list is_prime of size n and initialize all entries to True.\n   - Set is_prime[0] and is_prime[1] to False because 0 and 1 are not prime numbers.\n\n2. **Marking non-primes:**\n   - For each number current from 2 to the square root of n:\n     - If is_prime[current] is True:\n     - Mark all multiples of current starting from current^2 up to n as non-prime by setting their entries in is_prime to False.\n\n3. **Counting Primes:**\n   - Count the number of True entries in the is_prime list, excluding 0 and 1.\n   - Return this count as the number of primes less than n.",
        "analysis": "**BEST CASE ANALYSIS**\n\n*Scenario:*\n- When n is very small (e.g., n ≤ 2). Here, the algorithm immediately returns 0 because there are no primes less than 2.\n\n*Time Complexity:*\n- O(1)\n\n*Space Complexity:*\n- O(1)\n\n\n**WORST CASE ANALYSIS**\n\n*Scenario:*\n- When n is a large number (e.g., n ≥ 10^6), requiring the algorithm to fully execute the sieve.\n\n*Time Complexity:*\n- O(n log log n)\n\n*Space Complexity:*\n- O(n)",
        "comparison": "**Time Complexity Comparison:**\n\n| Scenario    | Time Complexity | Space Complexity |\n|-------------|------------------|------------------|\n| Best Case   | O(1)             | O(1)             |\n| Worst Case  | O(nloglogn)      | O(n)             |",
        "code": "JAVA CODE:\npublic class CountPrimes {\n    public int countPrimes(int n) {\n        if (n <= 2) {\n            return 0;\n        }\n\n        boolean[] isPrime = new boolean[n];\n        Arrays.fill(isPrime, true);\n        isPrime[0] = isPrime[1] = false;\n\n        for (int current = 2; current * current < n; current++) {\n            if (isPrime[current]) {\n                for (int multiple = current * current; multiple < n; multiple += current) {\n                    isPrime[multiple] = false;\n                }\n            }\n        }\n\n        int count = 0;\n        for (boolean prime : isPrime) {\n            if (prime) {\n                count++;\n            }\n        }\n        return count;\n    }\n}\n\n\nC++ CODE:\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nint countPrimes(int n) {\n    if (n <= 2) {\n        return 0;\n    }\n    vector<bool> isPrime(n, true);\n    isPrime[0] = isPrime[1] = false;\n\n    for (int current = 2; current * current < n; current++) {\n        if (isPrime[current]) {\n            for (int multiple = current * current; multiple < n; multiple += current) {\n                isPrime[multiple] = false;\n            }\n        }\n    }\n\n    int count = 0;\n    for (bool prime : isPrime) {\n        if (prime) {\n            count++;\n        }\n    }\n    return count;\n}"
      },
      {
        "title": "GCD of Array",
        "description": "## Problem Description\n\nGiven an array `arr`, return the greatest common divisor (GCD) of the smallest and largest elements in the array.",
        "algorithm": "## Approaches:\n\n### a. Brute Force Approach:\n1. **Find min and max:** Traverse the array to find the smallest (`min_num`) and largest (`max_num`) elements.\n2. **Compute GCD:**\n   - Initialize `gcd_result = 1`.\n   - Iterate from `i = 1` to `min_num`:\n     - If both `min_num` and `max_num` are divisible by `i`, update `gcd_result = i`.\n3. **Return gcd_result**.\n\n### b. Optimal Approach (Euclidean Algorithm):\n1. **Find min and max:** Traverse the array to find the smallest and largest elements.\n2. **Apply Euclidean Algorithm:**\n   - While `min_num != 0`, do:\n     - Compute `max_num % min_num`\n     - Update `max_num = min_num` and `min_num = remainder`\n3. **Return max_num** (when `min_num = 0`).",
        "comparison": [
          {
            "algorithm": "Brute Force",
            "time": "O(n + min_num)",
            "space": "O(1)"
          },
          {
            "algorithm": "Euclidean Algorithm",
            "time": "O(n + log(min_num))",
            "space": "O(1)"
          }
        ],
        "analysis": "## Best- and Worst-Case Analysis\n\n### 1. Brute Force (Naive GCD Calculation)\n**Best-Case:**\n- Input: Array where min and max are equal (e.g., [5, 5, 5])\n- Time: O(n) (to find min and max) + O(1) (GCD)\n- Space: O(1)\n\n**Worst-Case:**\n- Input: min and max are consecutive Fibonacci numbers (e.g., [5, 8])\n- Time: O(n + log(min))\n- Space: O(1)\n\n### 2. Optimal (Euclidean Algorithm)\n**Best-Case:**\n- Input: min divides max (e.g., [2, 4, 8])\n- Time: O(n) + O(1) = O(n)\n- Space: O(1)\n\n**Worst-Case:**\n- Input: min and max are consecutive Fibonacci numbers (e.g., [8, 13])\n- Time: O(n + log(min))\n- Space: O(1)",
        "code": "JAVA CODE:\n\n// BRUTE FORCE:\nimport java.util.Arrays;\nclass Solution {\n    public int findGCD(int[] nums) {\n        int min_num = Arrays.stream(nums).min().getAsInt();\n        int max_num = Arrays.stream(nums).max().getAsInt();\n\n        int gcd_result = 1;\n        for (int i = 1; i <= min_num; ++i) {\n            if (min_num % i == 0 && max_num % i == 0) {\n                gcd_result = i;\n            }\n        }\n        return gcd_result;\n    }\n}\n\n\n// OPTIMAL:\nimport java.util.Arrays;\nclass Solution {\n    private int gcd(int a, int b) {\n        while (b != 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n\n    public int findGCD(int[] nums) {\n        int min_num = Arrays.stream(nums).min().getAsInt();\n        int max_num = Arrays.stream(nums).max().getAsInt();\n        return gcd(min_num, max_num);\n    }\n}\n\n\nC++ CODE:\n\n// BRUTE FORCE:\n#include <vector>\n#include <algorithm>\nusing namespace std;\nclass Solution {\npublic:\n    int findGCD(vector<int>& nums) {\n        int min_num = *min_element(nums.begin(), nums.end());\n        int max_num = *max_element(nums.begin(), nums.end());\n\n        int gcd_result = 1;\n        for (int i = 1; i <= min_num; ++i) {\n            if (min_num % i == 0 && max_num % i == 0) {\n                gcd_result = i;\n            }\n        }\n        return gcd_result;\n    }\n};\n\n\n// OPTIMAL:\n#include <vector>\n#include <algorithm>\nusing namespace std;\nclass Solution {\npublic:\n    int gcd(int a, int b) {\n        while (b != 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n\n    int findGCD(vector<int>& nums) {\n        int min_num = *min_element(nums.begin(), nums.end());\n        int max_num = *max_element(nums.begin(), nums.end());\n        return gcd(min_num, max_num);\n    }\n};"
      },
      {
        "title": "Number of Set Bits",
        "description": "## Problem Description\n\nGiven a positive integer `num`, write a function that returns the number of set bits in its binary representation (also known as the Hamming weight).\n\n### Example:\n**Input:** `num = 7`\n\n**Output:** `3` (because `7` in binary is `111`, which has 3 set bits).",
        "algorithm": "## Approaches\n\n### a. Basic Approach (Right Shift)\n\n**Steps:**\n1. Initialize `count = 0`.\n2. While `num > 0`:\n   - Check LSB: `num & 1` gives the least significant bit.\n   - If it's set, increment `count`.\n   - Right shift `num` using `>>`.\n3. Return `count`.\n\n### b. Optimized Approach (Brian Kernighan's Algorithm)\n\n**Steps:**\n1. Initialize `count = 0`.\n2. While `num > 0`:\n   - Do `num = num & (num - 1)` to remove the least significant set bit.\n   - Increment `count`.\n3. Return `count`.",
        "analysis": "## Best- and Worst-Case Analysis\n\n### 1. Naive Approach (Right Shift)\n\n**Best Case:**\n- Input: `num = 0`\n- Loop terminates immediately.\n- **Time:** O(1), **Space:** O(1)\n\n**Worst Case:**\n- Input: `num = 2³¹ - 1` (all bits set)\n- Must check all 32 bits.\n- **Time:** O(32) = O(1), **Space:** O(1)\n\n### 2. Optimized Approach (Kernighan's Algorithm)\n\n**Best Case:**\n- Input: `num = 0`\n- Loop terminates immediately.\n- **Time:** O(1), **Space:** O(1)\n\n**Worst Case:**\n- Input: `num = 2³¹ - 1`\n- Clears each bit individually in 32 iterations.\n- **Time:** O(32) = O(1), **Space:** O(1)",
        "comparison": [
          {
            "algorithm": "Basic (Right Shift)",
            "time": "O(log num)",
            "space": "O(1)"
          },
          {
            "algorithm": "Kernighan's Algorithm",
            "time": "O(log num)",
            "space": "O(1)"
          }
        ],
        "code": "JAVA CODE:\n\n// BRUTE FORCE:\nclass Solution {\n    public int hammingWeight(int n) {\n        int count = 0;\n        while (n != 0) {\n            count += n & 1;\n            n = n >>> 1; // Unsigned right shift\n        }\n        return count;\n    }\n}\n\n// OPTIMAL APPROACH:\nclass Solution {\n    public int hammingWeight(int n) {\n        int count = 0;\n        while (n != 0) {\n            n = n & (n - 1); // Clears the least significant set bit\n            count++;\n        }\n        return count;\n    }\n}\n\n\nC++ CODE:\n\n// BRUTE FORCE:\nclass Solution {\npublic:\n    int hammingWeight(int n) {\n        int count = 0;\n        while (n != 0) {\n            count += n & 1;\n            n = n >> 1; // Right shift\n        }\n        return count;\n    }\n};\n\n// OPTIMAL APPROACH:\nclass Solution {\npublic:\n    int hammingWeight(int n) {\n        int count = 0;\n        while (n != 0) {\n            n = n & (n - 1); // Clears the least significant set bit\n            count++;\n        }\n        return count;\n    }\n};"
      },
      {
        "title": "Single Number",
        "link": "https://leetcode.com/problems/single-number/description/?envType=problem-list-v2&envId=bitmanipulation",
        "difficulty": "Easy"
      },
      {
        "title": "Counting Bits",
        "description": "## Problem Description\n\nGiven a non-negative integer `num`, return an array `count` of length `num + 1` where each entry `count[i]` represents the number of 1's in the binary representation of `i`.\n\nThe solution should efficiently compute the counts for all numbers from 0 to `num`.\n\n### Example 1:\n**Input:** num = 2\n**Output:** [0, 1, 1]\n**Explanation:**\n- 0 → 0 → 0 ones\n- 1 → 1 → 1 one\n- 2 → 10 → 1 one\n\n### Example 2:\n**Input:** num = 5\n**Output:** [0, 1, 1, 2, 1, 2]\n**Explanation:**\n- 0 → 0 → 0 ones\n- 1 → 1 → 1 one\n- 2 → 10 → 1 one\n- 3 → 11 → 2 ones\n- 4 → 100 → 1 one\n- 5 → 101 → 2 ones",
        "algorithm": "## Approaches\n\n### 1. Brute-Force Approach (Count Bits Individually)\n\n**Approach:**\n- Iterate from 0 to `num`:\n  - Convert each `i` to binary.\n  - Count the number of 1s in its binary representation.\n\n**Steps:**\n1. Initialize an array `count` of size `num + 1`.\n2. For each `i` from 0 to `num`:\n   - Convert `i` to binary.\n   - Count the number of 1s.\n   - Store the count in `count[i]`.\n\n---\n\n### 2. Optimal Approach (Dynamic Programming)\n\n**Approach:**\n- Use the result of previous computations.\n- The number of 1s in `i` is `count[i >> 1] + (i & 1)`.\n\n**Steps:**\n1. Initialize an array `count` of size `num + 1`.\n2. Set `count[0] = 0`.\n3. For each `i` from 1 to `num`:\n   - `count[i] = count[i >> 1] + (i & 1)`.",
        "analysis": "## Best- and Worst-Case Analysis\n\n### 1. Brute-Force Approach (Count Bits Individually)\n\n**Best-Case Scenario:**\n- Input: `num = 0`\n- Only computes `count[0] = 0`\n- **Time Complexity:** O(1)\n- **Space Complexity:** O(1)\n\n**Worst-Case Scenario:**\n- Input: Large num (e.g., `num = 10^6`)\n- Each number converted to binary and 1s are counted\n- **Time Complexity:** O(n log n)\n- **Space Complexity:** O(1) (excluding output array)\n\n---\n\n### 2. Optimal Approach (Dynamic Programming)\n\n**Best-Case Scenario:**\n- Input: Any value (e.g., `num = 10^6`)\n- Each value computed in constant time using formula\n- **Time Complexity:** O(n)\n- **Space Complexity:** O(1) (excluding output array)\n\n**Worst-Case Scenario:**\n- Same as best-case (performance consistent)\n- **Time Complexity:** O(n)\n- **Space Complexity:** O(1)",
        "comparison": [
          {
            "algorithm": "Brute-Force (Count Bits Individually)",
            "time": "O(n log n)",
            "space": "O(1)"
          },
          {
            "algorithm": "Optimal (Dynamic Programming)",
            "time": "O(n)",
            "space": "O(1)"
          }
        ],
        "code": "JAVA CODE:\n\n// BRUTE FORCE:\nclass Solution {\n    public int[] countBits(int n) {\n        int[] ans = new int[n + 1];\n        for (int i = 0; i <= n; i++) {\n            ans[i] = Integer.bitCount(i); // Built-in bit count\n        }\n        return ans;\n    }\n}\n\n// OPTIMAL APPROACH:\nclass Solution {\n    public int[] countBits(int n) {\n        int[] dp = new int[n + 1];\n        for (int i = 1; i <= n; i++) {\n            dp[i] = dp[i >> 1] + (i & 1); // i/2 + last bit\n        }\n        return dp;\n    }\n}\n\n\nC++ CODE:\n\n// BRUTE FORCE:\n#include <vector>\n#include <bitset>\n\nclass Solution {\npublic:\n    std::vector<int> countBits(int n) {\n        std::vector<int> ans(n + 1);\n        for (int i = 0; i <= n; ++i) {\n            ans[i] = std::bitset<32>(i).count(); // Count 1's in binary representation\n        }\n        return ans;\n    }\n};\n\n// OPTIMAL APPROACH:\n#include <vector>\n\nclass Solution {\npublic:\n    std::vector<int> countBits(int n) {\n        std::vector<int> dp(n + 1, 0);\n        for (int i = 1; i <= n; ++i) {\n            dp[i] = dp[i >> 1] + (i & 1); // i/2 + last bit\n        }\n        return dp;\n    }\n};"
      },
      {
        "title": "Reverse Bits",
        "description": "## Problem Description\n\nGiven a 32-bit unsigned integer `x`, reverse all its bits and return the resulting integer.\n\n**Notes:**\n- Some languages (like Java) do not have unsigned integers. In such cases, the input and output will be treated as signed integers, but the binary reversal should still work correctly because the internal bit representation remains the same.\n- In Java, integers use 2's complement representation, so negative inputs/outputs are possible but do not affect the bit reversal logic.\n\n### Example 1:\n**Input:**\n`x = 0b00000010100101000001111010011100` (Decimal: 43261596)\n\n**Output:**\n`964176192` (Binary: `0b00111001011110000010100101000000`)\n\n**Explanation:**\nInput `00000010100101000001111010011100` → Reversed `00111001011110000010100101000000`\n\n### Example 2:\n**Input:**\n`x = 0b11111111111111111111111111111101` (Decimal: 4294967293 or -3 in Java)\n\n**Output:**\n`3221225471` (Binary: `0b10111111111111111111111111111111`)\n\n**Explanation:**\nInput `11111111111111111111111111111101` → Reversed `10111111111111111111111111111111`",
        "algorithm": "## Approaches:\n\n### 1. Brute-Force Approach (Bit-by-Bit Reversal)\n\n**Approach:**\n- Extract Bits: Iterate over each bit of the input number.\n- Reverse Bits: Construct the reversed number by placing bits in reverse order.\n\n**Steps:**\n1. Initialize `result = 0`\n2. For each of the 32 bits:\n   - Extract the least significant bit (LSB) using `x & 1`\n   - Left-shift result by 1 and add the extracted bit\n   - Right-shift `x` to process the next bit\n3. Return result\n\n---\n\n### 2. Optimal Approach (Divide and Conquer Bit Manipulation)\n\n**Approach:**\n- Swap Bit Chunks: Use bitmasking and shifting to reverse bits in logarithmic steps:\n  - Swap left and right 16-bit halves\n  - Swap 8-bit chunks within each 16-bit half\n  - Continue down to individual bits\n\n**Steps:**\n1. `x = (x >> 16) | (x << 16)`\n2. `x = ((x & 0xff00ff00) >> 8) | ((x & 0x00ff00ff) << 8)`\n3. `x = ((x & 0xf0f0f0f0) >> 4) | ((x & 0x0f0f0f0f) << 4)`\n4. `x = ((x & 0xcccccccc) >> 2) | ((x & 0x33333333) << 2)`\n5. `x = ((x & 0xaaaaaaaa) >> 1) | ((x & 0x55555555) << 1)`",
        "comparison": [
          {
            "algorithm": "Brute-Force",
            "time": "O(1)",
            "space": "O(1)"
          },
          {
            "algorithm": "Optimal (D&C)",
            "time": "O(1)",
            "space": "O(1)"
          }
        ],
        "analysis": "## Best- and Worst-Case Analysis for Both Algorithms\n\n### 1. Brute-Force Approach (Bit-by-Bit Reversal)\n\n**Best-Case Scenario**\n- Input: `0` (all bits unset)\n- Still requires 32 iterations (no early termination)\n- Time Complexity: `O(32)` = `O(1)` (fixed 32 steps)\n- Space Complexity: `O(1)`\n\n**Worst-Case Scenario**\n- Input: Any 32-bit number (e.g., `0xFFFFFFFF`)\n- Still requires 32 iterations\n- Time Complexity: `O(1)`\n- Space Complexity: `O(1)`\n\n---\n\n### 2. Optimal Approach (Divide and Conquer)\n\n**Best-Case Scenario**\n- Input: Any 32-bit number\n- Executes exactly 5 bitmask operations (no loops)\n- Time Complexity: `O(1)` (constant time)\n- Space Complexity: `O(1)`\n\n**Worst-Case Scenario**\n- Input: Same as best case (no performance variation)\n- Always 5 steps: swap 16-bit, 8-bit, 4-bit, 2-bit, and 1-bit chunks\n- Time Complexity: `O(1)`\n- Space Complexity: `O(1)`",
        "code": "JAVA CODE:\n\n// BRUTE FORCE:\npublic class Solution {\n    public int reverseBits(int n) {\n        int result = 0;\n        for (int i = 0; i < 32; i++) {\n            result = (result << 1) | (n & 1);\n            n >>>= 1; // Unsigned right shift\n        }\n        return result;\n    }\n}\n\n// OPTIMAL APPROACH:\npublic class Solution {\n    public int reverseBits(int n) {\n        n = (n >>> 16) | (n << 16);\n        n = ((n & 0xff00ff00) >>> 8) | ((n & 0x00ff00ff) << 8);\n        n = ((n & 0xf0f0f0f0) >>> 4) | ((n & 0x0f0f0f0f) << 4);\n        n = ((n & 0xcccccccc) >>> 2) | ((n & 0x33333333) << 2);\n        n = ((n & 0xaaaaaaaa) >>> 1) | ((n & 0x55555555) << 1);\n        return n;\n    }\n}\n\n\nC++ CODE:\n\n// BRUTE FORCE:\nclass Solution {\npublic:\n    uint32_t reverseBits(uint32_t n) {\n        uint32_t result = 0;\n        for (int i = 0; i < 32; i++) {\n            result = (result << 1) | (n & 1);\n            n >>= 1;\n        }\n        return result;\n    }\n};\n\n// OPTIMAL APPROACH:\nclass Solution {\npublic:\n    uint32_t reverseBits(uint32_t n) {\n        n = (n >> 16) | (n << 16);\n        n = ((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8);\n        n = ((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4);\n        n = ((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2);\n        n = ((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1);\n        return n;\n    }\n};"
      },
      {
        "title": "Power of Two",
        "description": "## Problem Description\n\nGiven an integer `num`, determine if it is a power of two. Return true if it is, otherwise return false.\n\nA number is considered a power of two if it can be expressed as 2 raised to some integer exponent (i.e., there exists an integer k such that `num == 2^k`).\n\n### Examples:\n**Input:** num = 8\n**Output:** true\n**Explanation:** 8 can be written as 2³ (2 × 2 × 2 = 8)\n\n**Input:** num = 1024\n**Output:** true\n**Explanation:** 1024 is 2¹⁰ (1024 = 2 × 2 × ... × 2, 10 times)\n\n**Input:** num = 18\n**Output:** false\n**Explanation:** There is no integer k where 2ᵏ equals 18",
        "algorithm": "## Approaches\n\n### 1. Brute-Force Approach (Loop and Divide)\n\n**Algorithm**\n\n**Handle Edge Cases:**\n- If `num ≤ 0`, return false.\n- If `num == 1`, return true.\n\n**Repeatedly Divide by 2:**\n- While `num > 1`, keep dividing `num` by 2.\n- If at any point `num % 2 != 0`, return false.\n- If `num` becomes 1, return true.\n\n---\n\n### 2. Optimal Approach (Bit Manipulation)\n\n**Algorithm**\n\n**Key Insight:**\n- A power of two has exactly one bit set in binary.\n- Subtracting 1 from a power of two flips all bits after the set bit.\n\n**Example:**\n- 8 (1000) → 7 (0111).\n- 16 (10000) → 15 (01111).\n\nTherefore, `num & (num - 1) == 0` for powers of two.\n\n**Edge Cases:**\n- `num ≤ 0` → Not a power of two.\n- `num == 1` → 2^0 = 1, so it is a power of two.",
        "analysis": "## Best- and Worst-Case Analysis\n\n### Algorithm 1: Brute-Force (Loop and Divide)\n\n**Best Case:**\n- **Scenario:** Input is odd and >1 (e.g., `num = 3`)\n- **Time Complexity:** O(1) (returns false immediately)\n- **Space Complexity:** O(1)\n\n**Worst Case:**\n- **Scenario:** Input is power of two (e.g., `num = 1024`)\n- **Time Complexity:** O(log n) (performs log₂n divisions)\n- **Space Complexity:** O(1)\n\n---\n\n### Algorithm 2: Optimal (Bit Manipulation)\n\n**Best Case:**\n- **Scenario:** Any input (including edge cases)\n- **Time Complexity:** O(1) (single bit operation)\n- **Space Complexity:** O(1)\n\n**Worst Case:**\n- **Scenario:** Same as best case (always constant time)\n- **Time Complexity:** O(1)\n- **Space Complexity:** O(1)",
        "comparison": [
          {
            "algorithm": "Brute-Force (Loop)",
            "time": "O(logn)",
            "space": "O(1)"
          },
          {
            "algorithm": "Optimal (Bitwise)",
            "time": "O(1)",
            "space": "O(1)"
          }
        ],
        "code": "JAVA CODE:\n\n// BRUTE FORCE:\nclass Solution {\n    public boolean isPowerOfTwo(int n) {\n        if (n <= 0) return false;\n        while (n % 2 == 0) n /= 2;\n        return n == 1;\n    }\n}\n\n// OPTIMAL APPROACH:\nclass Solution {\n    public boolean isPowerOfTwo(int n) {\n        return n > 0 && (n & (n - 1)) == 0;\n    }\n}\n\n\nC++ CODE:\n\n// BRUTE FORCE:\nclass Solution {\npublic:\n    bool isPowerOfTwo(int n) {\n        if (n <= 0) return false;\n        while (n % 2 == 0) n /= 2;\n        return n == 1;\n    }\n};\n\n// OPTIMAL APPROACH:\nclass Solution {\npublic:\n    bool isPowerOfTwo(int n) {\n        return n > 0 && (n & (n - 1)) == 0;\n    }\n};"
      },
      {
        "title": "Missing Number",
        "description": "## Problem Description\n\nGiven an array `arr` of `n` unique integers where all elements lie in the range `[0, n]`, find the single missing number in this range.\n\n### Example 1:\n**Input:** arr = [2, 1, 0]  \n**Output:** 3  \n**Explanation:** The array has 3 elements, so the full range is [0, 3]. The numbers present are {0, 1, 2}, so 3 is missing.\n\n### Example 2:\n**Input:** arr = [0, 1]  \n**Output:** 2  \n**Explanation:** The array has 2 elements, so the full range is [0, 2]. The numbers present are {0, 1}, so 2 is missing.\n\n### Example 3:\n**Input:** arr = [5, 3, 1, 4, 2, 7, 0, 9, 6]  \n**Output:** 8  \n**Explanation:** The array has 9 elements, so the full range is [0, 9]. The numbers present are {0, 1, 2, 3, 4, 5, 6, 7, 9}, so 8 is missing.",
        "algorithm": "## Approaches\n\n### 1. Brute-Force Approach (Linear Search)\n\n**Approach:**\n- **Sort the Array:** Sort the array to bring numbers in order.\n- **Check for Missing Number:** Iterate through the sorted array and compare each element with its index.\n  - The first index where `arr[i] != i` indicates the missing number is `i`.\n  - If all elements match their indices, the missing number is `n`.\n\n**Step-by-Step:**\n- Sort the array (e.g., `[2, 1, 0]` → `[0, 1, 2]`).\n- Traverse the sorted array:\n   - If `arr[i] != i`, return `i`.\n   - If no mismatch is found, return `n`.\n\n**Time Complexity:** O(n log n) (due to sorting)  \n**Space Complexity:** O(1) (if sorted in-place)\n\n---\n\n### 2.a. Optimal Approach (Mathematical Sum)\n\n**Approach:**\n- **Calculate Expected Sum:** The sum of numbers in `[0, n]` is `n*(n+1)/2`.\n- **Calculate Actual Sum:** Sum all elements in the array.\n- **Missing Number:** `Missing = Expected Sum - Actual Sum`.\n\n**Step-by-Step:**\n- Compute `expected_sum = n*(n+1)/2` (since n = `arr.length`).\n- Compute `actual_sum` by summing all elements in `arr`.\n- Return `expected_sum - actual_sum`.\n\n**Time Complexity:** O(n) (single pass to compute sum)  \n**Space Complexity:** O(1) (only a few variables)\n\n---\n\n### 2.b. Optimal Approach (Bitwise XOR)\n\n**Approach:**\n- **XOR Property:**\n  - `a ^ a = 0` (XOR of a number with itself cancels it out)\n  - `a ^ 0 = a` (XOR with 0 returns the number)\n- **Compute XOR of All Numbers in [0, n] and arr:**\n  - The missing number will be the result of this XOR operation.\n\n**Step-by-Step:**\n- Initialize `xor_result = 0`.\n- XOR all numbers from `0 to n` with `xor_result`.\n- XOR all elements in `arr` with `xor_result`.\n- The remaining value in `xor_result` is the missing number.",
        "analysis": "## Best- and Worst-Case Analysis\n\n### 1. Brute-Force (Sort + Linear Scan)\n\n**Best-Case Scenario**  \n **Input:** Missing number is `0` (e.g., arr = `[1, 2, 3]`, missing 0).  \n**Behavior:**\n- Sorting takes O(n log n) time.\n- Immediate mismatch at index 0 during scan.\n\n**Time Complexity:** O(n log n) (dominated by sorting)  \n**Space Complexity:** O(1) (if sorted in-place)\n\n**Worst-Case Scenario**  \n**Input:** Missing number is `n` (e.g., arr = `[0, 1, 2]`, missing 3).  \n**Behavior:**\n- Sorting still O(n log n).\n- Full linear scan required (O(n)).\n\n**Time Complexity:** O(n log n)  \n**Space Complexity:** O(1)\n\n**Key Limitation:**\n- Sorting is unnecessary and inefficient for this problem.\n\n---\n\n### 2. Optimal (Sum of Range - Sum of Array)\n\n**Best- and Worst-Case Scenario**  \n**Input:** Any valid array (no variability).  \n**Behavior:**\n- Compute expected sum (`n*(n+1)/2`) in O(1).\n- Sum array elements in O(n).\n\n**Time Complexity:** O(n) (always single pass)  \n**Space Complexity:** O(1)\n\n**Edge Case:**\n- **Integer Overflow:** For very large `n` (e.g., `n = 10⁹`), `n*(n+1)/2` may exceed `INT_MAX`.\n\n---\n\n### 3. Optimal (XOR All Numbers)\n\n**Best- and Worst-Case Scenario**  \n**Input:** Any valid array (no variability).  \n**Behavior:**\n- Two passes: XOR numbers in `[0, n]` and array elements.\n\n**Time Complexity:** O(n) (always two passes)  \n**Space Complexity:** O(1)\n\n**Advantage Over Sum:**\n- No risk of integer overflow.",
        "comparison": [
          {
            "algorithm": "Brute-Force",
            "time": "O(n log n)",
            "space": "O(1)"
          },
          {
            "algorithm": "Sum (Optimal)",
            "time": "O(n)",
            "space": "O(1)"
          },
          {
            "algorithm": "XOR (Optimal)",
            "time": "O(n)",
            "space": "O(1)"
          }
        ],
        "code": "JAVA CODE:\n\n// BRUTE FORCE:\nimport java.util.Arrays;\n\nclass Solution {\n    public int missingNumber(int[] nums) {\n        Arrays.sort(nums);\n        int n = nums.length;\n        for (int i = 0; i < n; i++) {\n            if (nums[i] != i) return i;\n        }\n        return n;\n    }\n}\n\n// OPTIMAL APPROACH (Sum of Range - Sum of Array):\nclass Solution {\n    public int missingNumber(int[] nums) {\n        int n = nums.length;\n        int expectedSum = n * (n + 1) / 2;\n        int actualSum = 0;\n        for (int num : nums) actualSum += num;\n        return expectedSum - actualSum;\n    }\n}\n\n// OPTIMAL APPROACH (XOR All Numbers):\nclass Solution {\n    public int missingNumber(int[] nums) {\n        int xorResult = 0;\n        int n = nums.length;\n        for (int i = 0; i <= n; i++) xorResult ^= i;\n        for (int num : nums) xorResult ^= num;\n        return xorResult;\n    }\n}\n\n\nC++ CODE:\n\n// BRUTE FORCE:\n#include <vector>\n#include <algorithm>\n\nclass Solution {\npublic:\n    int missingNumber(std::vector<int>& nums) {\n        std::sort(nums.begin(), nums.end());\n        int n = nums.size();\n        for (int i = 0; i < n; i++) {\n            if (nums[i] != i) return i;\n        }\n        return n;\n    }\n};\n\n// OPTIMAL APPROACH (Sum of Range - Sum of Array):\n#include <vector>\n#include <numeric>\n\nclass Solution {\npublic:\n    int missingNumber(std::vector<int>& nums) {\n        int n = nums.size();\n        int expectedSum = n * (n + 1) / 2;\n        int actualSum = std::accumulate(nums.begin(), nums.end(), 0);\n        return expectedSum - actualSum;\n    }\n};\n\n// OPTIMAL APPROACH (XOR All Numbers):\n#include <vector>\n\nclass Solution {\npublic:\n    int missingNumber(std::vector<int>& nums) {\n        int xorResult = 0;\n        int n = nums.size();\n        for (int i = 0; i <= n; i++) xorResult ^= i;\n        for (int num : nums) xorResult ^= num;\n        return xorResult;\n    }\n};"
      },
      {
        "title": "Set Kth Bit"
      }
    ]
  },
  {
    "topicName": "Recursion",
    "problems": [
      {
        "title": "Fibonacci Number",
        "description": "## Problem Description\n\nGiven an integer `n`, return the nth Fibonacci number, defined as:\n- F(0) = 0\n- F(1) = 1\n- F(n) = F(n - 1) + F(n - 2), for n > 1\n\n### Example 1\n**Input:** n = 2\n**Output:** 1\n**Explanation:** F(2) = F(1) + F(0) = 1 + 0 = 1\n\n### Example 2\n**Input:** n = 3\n**Output:** 2\n**Explanation:** F(3) = F(2) + F(1) = 1 + 1 = 2",
        "algorithm": "## Approaches\n\n### a. Brute Force Approach (Recursive)\nThis approach follows the direct recursive definition of Fibonacci numbers.\n\n**Steps:**\n1. Base Cases:\n   - If `n == 0`, return 0\n   - If `n == 1`, return 1\n2. Recursive Case:\n   - Return `fib(n - 1) + fib(n - 2)`\n\nExample (n = 4):\n- fib(4) = fib(3) + fib(2)\n- fib(3) = fib(2) + fib(1)\n- fib(2) = fib(1) + fib(0) = 1 + 0 = 1\n- fib(4) = 2 + 1 = 3\n\n### b. Optimal Approach (Iterative Dynamic Programming)\nAvoids redundant calls by using iteration and storing intermediate results.\n\n**Steps:**\n1. Handle base cases:\n   - If `n == 0`, return 0\n   - If `n == 1`, return 1\n2. Initialize: `a = 0`, `b = 1`\n3. Loop from `2` to `n`:\n   - `c = a + b`\n   - Update `a = b`, `b = c`\n4. Return `b`",
        "analysis": "## Best- and Worst-Case Analysis\n\n### 1. Brute-Force (Recursive)\n **Best-Case:**\n  - Input: n = 0 or 1\n  - Returns immediately\n  - Time: O(1), Space: O(1)\n\n **Worst-Case:**\n  - Input: Large `n` (e.g., 40)\n  - Many redundant recursive calls\n  - Time: O(2^n), Space: O(n) (due to call stack)\n\n### 2. Optimal (Dynamic Programming - Iterative)\n **Best- and Worst-Case:**\n  - Input: Any `n`\n  - Time: O(n), Space: O(1)\n  - Always consistent and efficient",
        "comparison": [
          {
            "algorithm": "Brute-Force (Recursive)",
            "time": "O(2^n)",
            "space": "O(n)"
          },
          {
            "algorithm": "Optimal (Iterative DP)",
            "time": "O(n)",
            "space": "O(1)"
          }
        ],
        "code": "JAVA CODE:\n\n// BRUTE FORCE:\nclass Solution {\n    public int fib(int n) {\n        if (n == 0) return 0;\n        if (n == 1) return 1;\n        return fib(n - 1) + fib(n - 2);\n    }\n}\n\n// OPTIMAL:\nclass Solution {\n    public int fib(int n) {\n        if (n == 0) return 0;\n        if (n == 1) return 1;\n\n        int a = 0, b = 1, c;\n        for (int i = 2; i <= n; i++) {\n            c = a + b;\n            a = b;\n            b = c;\n        }\n        return b;\n    }\n}\n\nC++ CODE:\n\n// BRUTE FORCE:\nclass Solution {\npublic:\n    int fib(int n) {\n        if (n == 0) return 0;\n        if (n == 1) return 1;\n        return fib(n - 1) + fib(n - 2);\n    }\n};\n\n// OPTIMAL:\nclass Solution {\npublic:\n    int fib(int n) {\n        if (n == 0) return 0;\n        if (n == 1) return 1;\n\n        int a = 0, b = 1, c;\n        for (int i = 2; i <= n; i++) {\n            c = a + b;\n            a = b;\n            b = c;\n        }\n        return b;\n    }\n};"
      },
      {
        "title": "Tower of Hanoi",
        "link": "https://www.geeksforgeeks.org/problems/tower-of-hanoi-1587115621/1",
        "difficulty": "Medium"
      },
      {
        "title": "Power of Two",
        "description": "## Problem Description\n\nGiven an integer `num`, determine if it is a power of two. Return true if it is, otherwise return false.\n\nA number is considered a power of two if it can be expressed as 2 raised to some integer exponent (i.e., there exists an integer k such that `num == 2^k`).\n\n### Examples:\n**Input:** num = 8 \n**Output:** true \n**Explanation:** 8 can be written as 2³ (2 × 2 × 2 = 8)\n\n**Input:** num = 1024\n**Output:** true\n  **Explanation:** 1024 is 2¹⁰ (1024 = 2 × 2 × ... × 2, 10 times)\n\n**Input:** num = 18\n  **Output:** false\n  **Explanation:** There is no integer k where 2ᵏ equals 18",
        "algorithm": "## Approaches\n\n### 1. Brute-Force Approach (Loop and Divide)\n\n**Algorithm**\n\n**Handle Edge Cases:**\n- If `num ≤ 0`, return false.\n- If `num == 1`, return true.\n\n**Repeatedly Divide by 2:**\n- While `num > 1`, keep dividing `num` by 2.\n- If at any point `num % 2 != 0`, return false.\n- If `num` becomes 1, return true.\n\n---\n\n### 2. Optimal Approach (Bit Manipulation)\n\n**Algorithm**\n\n**Key Insight:**\n- A power of two has exactly one bit set in binary.\n- Subtracting 1 from a power of two flips all bits after the set bit.\n\n**Example:**\n- 8 (1000) → 7 (0111).\n- 16 (10000) → 15 (01111).\n\nTherefore, `num & (num - 1) == 0` for powers of two.\n\n**Edge Cases:**\n- `num ≤ 0` → Not a power of two.\n- `num == 1` → 2^0 = 1, so it is a power of two.",
        "analysis": "## Best- and Worst-Case Analysis\n\n### Algorithm 1: Brute-Force (Loop and Divide)\n\n**Best Case:**\n- **Scenario:** Input is odd and >1 (e.g., `num = 3`)\n- **Time Complexity:** O(1) (returns false immediately)\n- **Space Complexity:** O(1)\n\n**Worst Case:**\n- **Scenario:** Input is power of two (e.g., `num = 1024`)\n- **Time Complexity:** O(log n) (performs log₂n divisions)\n- **Space Complexity:** O(1)\n\n---\n\n### Algorithm 2: Optimal (Bit Manipulation)\n\n**Best Case:**\n- **Scenario:** Any input (including edge cases)\n- **Time Complexity:** O(1) (single bit operation)\n- **Space Complexity:** O(1)\n\n**Worst Case:**\n- **Scenario:** Same as best case (always constant time)\n- **Time Complexity:** O(1)\n- **Space Complexity:** O(1)",
        "comparison": [
          {
            "algorithm": "Brute-Force (Loop)",
            "time": "O(logn)",
            "space": "O(1)"
          },
          {
            "algorithm": "Optimal (Bitwise)",
            "time": "O(1)",
            "space": "O(1)"
          }
        ],
        "code": "JAVA CODE:\n\n// BRUTE FORCE:\nclass Solution {\n    public boolean isPowerOfTwo(int n) {\n        if (n <= 0) return false;\n        while (n % 2 == 0) n /= 2;\n        return n == 1;\n    }\n}\n\n// OPTIMAL APPROACH:\nclass Solution {\n    public boolean isPowerOfTwo(int n) {\n        return n > 0 && (n & (n - 1)) == 0;\n    }\n}\n\n\nC++ CODE:\n\n// BRUTE FORCE:\nclass Solution {\npublic:\n    bool isPowerOfTwo(int n) {\n        if (n <= 0) return false;\n        while (n % 2 == 0) n /= 2;\n        return n == 1;\n    }\n};\n\n// OPTIMAL APPROACH:\nclass Solution {\npublic:\n    bool isPowerOfTwo(int n) {\n        return n > 0 && (n & (n - 1)) == 0;\n    }\n};"
      },
      {
        "title": "Power Function",
        "description": "## Problem Description\n\nImplement a function `compute_power(base, exponent)` that calculates base raised to the power of exponent (i.e., base^exponent). The function should efficiently handle both positive and negative exponents.\n\n### Examples:\n**Input:** base = 3.0, exponent = 4  \n**Output:** 81.0  \n**Explanation:** 3⁴ = 3 × 3 × 3 × 3 = 81\n\n**Input:** base = 1.5, exponent = 3  \n**Output:** 3.375  \n**Explanation:** 1.5³ = 1.5 × 1.5 × 1.5 = 3.375\n\n**Input:** base = 5.0, exponent = -2  \n**Output:** 0.04  \n**Explanation:** 5⁻² = 1/(5²) = 1/25 = 0.04",
        "algorithm": "## Approaches\n\n### 1. Brute-Force Approach (Loop and Multiply/Divide)\n\n**Algorithm:**\n\n **Handle Edge Cases:**\n  - If `exponent == 0`, return 1 (any number to the power of 0 is 1).\n  - If `base == 0` and `exponent` is negative, it is undefined (but assume base ≠ 0 here).\n\n **Positive Exponent:**\n  - Initialize `result = 1`.\n  - Loop `exponent` times, multiplying `result` by `base`.\n\n **Negative Exponent:**\n  - Compute the absolute value of `exponent`.\n  - Multiply result by base in loop, then return `1 / result`.\n\n---\n\n### 2. Optimal Approach (Exponentiation by Squaring)\n\n**Algorithm:**\n\n **Handle Edge Cases:**\n  - If `exponent == 0`, return 1.\n  - If `base == 0` and `exponent` is negative, it is undefined.\n\n **Positive/Negative Exponent:**\n  - Use the properties:\n    - **Even Exponent:**  \n      `base^exponent = (base^(exponent/2))^2`\n    - **Odd Exponent:**  \n      `base^exponent = base * (base^((exponent-1)/2))^2`\n  - Compute power recursively or iteratively by halving exponent.\n  - If exponent is negative, take reciprocal of result.",
        "analysis": "## Best- and Worst-Case Analysis\n\n### 1. Brute-Force (Loop) Approach\n\n**Best-Case:**\n- Scenario: `exponent = 0`\n- Operations: Returns 1 immediately\n- Time: O(1)\n\n**Worst-Case:**\n- Scenario: Any |exponent| > 0 (positive or negative)\n- Operations: Performs exactly |exponent| multiplications/divisions\n- Time: O(n), where n = |exponent|\n- Examples:\n  - `2^1000` → 1000 multiplications\n  - `5^-500` → 500 multiplications + 1 division\n- Space: O(1)\n\n---\n\n### 2. Optimal (Exponentiation by Squaring)\n\n**Best-Case:**\n- Scenario: `exponent = 0`\n- Operations: Returns 1 immediately\n- Time: O(1)\n\n**Worst-Case:**\n- Scenario: Exponents where halving requires extra multiplication (odd exponents)\n- Operations: For n = |exponent|, number of steps is floor(log₂n) + (number of '1' bits in binary of n)\n- Upper Bound: 2 * log₂n steps\n- Time: O(log n)\n- Space: O(1)",
        "comparison": [
          {
            "algorithm": "Brute-Force (Loop)",
            "time": "O(n)",
            "space": "O(1)"
          },
          {
            "algorithm": "Optimal (Exponentiation by Squaring)",
            "time": "O(log n)",
            "space": "O(1)"
          }
        ],
        "code": "JAVA CODE:\n\n// BRUTE FORCE:\nclass Solution {\n    public double myPow(double x, int n) {\n        if (n == 0) return 1.0;\n        long N = n; // Handle Integer.MIN_VALUE overflow\n        if (N < 0) {\n            x = 1 / x;\n            N = -N;\n        }\n        double result = 1.0;\n        for (long i = 0; i < N; i++) {\n            result *= x;\n        }\n        return result;\n    }\n}\n\n// OPTIMAL APPROACH:\nclass Solution {\n    public double myPow(double x, int n) {\n        if (n == 0) return 1.0;\n        long N = n; // Handle Integer.MIN_VALUE overflow\n        if (N < 0) {\n            x = 1 / x;\n            N = -N;\n        }\n        double result = 1.0;\n        while (N > 0) {\n            if (N % 2 == 1) {\n                result *= x;\n            }\n            x *= x;\n            N /= 2;\n        }\n        return result;\n    }\n}\n\n\nC++ CODE:\n\n// BRUTE FORCE:\nclass Solution {\npublic:\n    double myPow(double x, int n) {\n        if (n == 0) return 1.0;\n        long N = n; // Handle INT_MIN overflow\n        if (N < 0) {\n            x = 1 / x;\n            N = -N;\n        }\n        double result = 1.0;\n        for (long i = 0; i < N; i++) {\n            result *= x;\n        }\n        return result;\n    }\n};\n\n// OPTIMAL APPROACH:\nclass Solution {\npublic:\n    double myPow(double x, int n) {\n        if (n == 0) return 1.0;\n        long N = n; // Handle INT_MIN overflow\n        if (N < 0) {\n            x = 1 / x;\n            N = -N;\n        }\n        double result = 1.0;\n        while (N > 0) {\n            if (N % 2 == 1) {\n                result *= x;\n            }\n            x *= x;\n            N /= 2;\n        }\n        return result;\n    }\n};"
      }
    ]
  },
  {
    "topicName": "Arrays",
    "problems": [
      {
        "title": "Leader in an array",
        "description": "## Problem Description\n\nProblem Statement:\nGiven an array nums, modify it by replacing each element with the largest element to its right. The last element should be replaced with -1. Return the modified array.\n\n### Examples:\n\n**Input:** nums = [12, 15, 8, 9, 10, 3]  \n**Output:** [15, 10, 10, 10, 3, -1]  \n**Explanation:**  \n12 is replaced by max(15, 8, 9, 10, 3) = 15  \n15 is replaced by max(8, 9, 10, 3) = 10  \n8 is replaced by max(9, 10, 3) = 10  \n9 is replaced by max(10, 3) = 10  \n10 is replaced by max(3) = 3  \n3 is last element → -1\n\n**Input:** nums = [100]  \n**Output:** [-1]  \n**Explanation:** Only one element exists → automatically becomes -1\n\n**Input:** nums = [5, 4, 3, 2, 1]  \n**Output:** [4, 3, 2, 1, -1]  \n**Explanation:** Each element is replaced by the next one since they are in descending order",
        "algorithm": "## Algorithm\n\n### 1. Brute-Force Approach (Nested Loops)\n\n**Algorithm:**\n- Iterate through each element in the array.\n- For each element, find the maximum element to its right by scanning all subsequent elements.\n- Replace the current element with this maximum value.\n- Set the last element to -1.\n\n### 2. Optimal Approach (Reverse Traversal with Tracking)\n\n**Algorithm:**\n- Initialize maxSoFar to -1 (since the last element should be -1).\n- Traverse the array from right to left:\n  - Store the current element's value temporarily.\n  - Replace the current element with maxSoFar.\n  - Update maxSoFar to be the maximum of its current value and the original value of the current element.\n- Return the modified array.",
        "comparison": [
          {
            "algorithm": "Brute-Force",
            "time": "O(n²)",
            "space": "O(1)"
          },
          {
            "algorithm": "Optimal",
            "time": "O(n)",
            "space": "O(1)"
          }
        ],
        "analysis": "## Best- and Worst-Case Analysis for Both Algorithms\n\n### 1. Brute-Force Approach (Nested Loops)\n\n**Best-Case:**  \n**Scenario:** Input array is in strictly descending order (e.g., [5,4,3,2,1]).  \n**Behavior:** Each element's right-max is its immediate neighbor → inner loop runs once per element.  \n**Time Complexity:** O(n) (degenerates to linear time).  \n**Space Complexity:** O(1) (in-place modification).\n\n**Worst-Case:**  \n**Scenario:** Input array is in strictly ascending order (e.g., [1,2,3,4,5]).  \n**Behavior:** For each element, the inner loop scans all remaining elements → full quadratic time.  \n**Time Complexity:** O(n²).  \n**Space Complexity:** O(1).\n\n### 2. Optimal Approach (Reverse Traversal)\n\n**Best-Case & Worst-Case:**  \n**Scenario:** All inputs behave identically (order-independent).  \n**Behavior:** Single right-to-left pass with constant-time updates.  \n**Time Complexity:** O(n) (always linear).  \n**Space Complexity:** O(1).",
        "code": "JAVA CODE:\n\n// BRUTE FORCE:\nclass Solution {\n    public int[] replaceElements(int[] arr) {\n        int n = arr.length;\n        for (int i = 0; i < n - 1; i++) {\n            int maxRight = arr[i + 1];\n            for (int j = i + 2; j < n; j++) {\n                if (arr[j] > maxRight) {\n                    maxRight = arr[j];\n                }\n            }\n            arr[i] = maxRight;\n        }\n        arr[n - 1] = -1;\n        return arr;\n    }\n}\n\n// OPTIMAL APPROACH:\nclass Solution {\n    public int[] replaceElements(int[] arr) {\n        int n = arr.length;\n        int maxSoFar = -1;\n        for (int i = n - 1; i >= 0; i--) {\n            int current = arr[i];\n            arr[i] = maxSoFar;\n            maxSoFar = Math.max(maxSoFar, current);\n        }\n        return arr;\n    }\n}\n\n\nC++ CODE:\n\n// BRUTE FORCE:\nclass Solution {\npublic:\n    vector<int> replaceElements(vector<int>& arr) {\n        int n = arr.size();\n        for (int i = 0; i < n - 1; i++) {\n            int maxRight = arr[i + 1];\n            for (int j = i + 2; j < n; j++) {\n                if (arr[j] > maxRight) {\n                    maxRight = arr[j];\n                }\n            }\n            arr[i] = maxRight;\n        }\n        arr[n - 1] = -1;\n        return arr;\n    }\n};\n\n// OPTIMAL APPROACH:\nclass Solution {\npublic:\n    vector<int> replaceElements(vector<int>& arr) {\n        int n = arr.size();\n        int maxSoFar = -1; // Initialize for the last element\n        for (int i = n - 1; i >= 0; i--) {\n            int current = arr[i];\n            arr[i] = maxSoFar;\n            maxSoFar = max(maxSoFar, current);\n        }\n        return arr;\n    }\n};"
      },
      {
        "title": "Sort an array of 0, 1 & 2",
        "link": "https://leetcode.com/problems/sort-colors/solutions/1745096/sort-colors-or-sort-an-array-of-0s-1s-and-2s/",
        "difficulty": "Medium"
      },
      {
        "title": "Kadenes Algorithm",
        "description": "## Problem Description\n\nGiven an integer array `arr`, find the contiguous subarray (sequence of adjacent elements) that yields the largest possible sum, and return that sum.\n\n### Examples:\n\n**Input:**\narr = [3, -1, -2, 4, -1, 2, 1, -3, 4]\n\n**Output:** 7\n\n**Explanation:**\nThe subarray [4, -1, 2, 1, -3, 4] has the maximum sum of 7.\n\n**Input:**\narr = [-2, -3, -1, -5]\n\n**Output:** -1\n\n**Explanation:**\nThe subarray [-1] (single element) has the maximum sum when all numbers are negative.\n\n**Input:**\narr = [2, 3, -2, 5, 6]\n\n**Output:** 14\n\n**Explanation:**\nThe entire array [2, 3, -2, 5, 6] gives the maximum sum.",
        "algorithm": "## Approaches:\n\n### 1. Brute-Force Approach (Nested Loops)\n\n**Algorithm:**\n- Initialize `max_sum` to the smallest possible value (e.g., INT_MIN).\n- Iterate over all possible starting indices `i` of the subarray.\n- For each `i`, iterate over all possible ending indices `j ≥ i`.\n- Compute the sum of the subarray `arr[i..j]` and update `max_sum` if this sum is larger.\n- Return `max_sum`.\n\n---\n\n### 2. Optimal Approach (Kadane's Algorithm)\n\n**Algorithm:**\n- Initialize `max_sum` and `current_sum` to the first element of the array.\n- Iterate through the array starting from the second element:\n  - Update `current_sum` to be the maximum of:\n    - The current element `arr[i]`, or\n    - The sum of `current_sum + arr[i]` (extending the subarray).\n  - Update `max_sum` if `current_sum` exceeds it.\n- Return `max_sum`.",
        "comparison": [
          {
            "algorithm": "Brute-Force",
            "time": "O(n²)",
            "space": "O(1)"
          },
          {
            "algorithm": "Kadane's (Optimal)",
            "time": "O(n)",
            "space": "O(1)"
          }
        ],
        "analysis": "## Best- and Worst-Case Analysis\n\n### 1. Brute-Force Approach (Nested Loops)\n\n**Best-Case Scenario**\n- **Input:** All elements are negative (e.g., `[-2, -3, -1, -5]`).\n- **Behavior:** Still checks all possible subarrays (no early termination). Inner loop runs completely for each starting index `i`.\n- **Time Complexity:** O(n²) (No optimization possible).\n- **Space Complexity:** O(1) (Fixed extra variables).\n\n**Worst-Case Scenario**\n- **Input:** All elements are positive (e.g., `[2, 3, 1, 5]`).\n- **Behavior:** Computes all subarray sums redundantly. Maximum subarray is the entire array, but still requires checking all `n(n+1)/2` subarrays.\n- **Time Complexity:** O(n²) (Same as best case).\n\n---\n\n### 2. Optimal Approach (Kadane's Algorithm)\n\n**Best-Case Scenario**\n- **Input:** All elements are positive (e.g., `[2, 3, 1, 5]`).\n- **Behavior:** `current_sum` grows monotonically (never resets to `arr[i]`). Single pass with constant-time updates.\n- **Time Complexity:** O(n)\n\n**Worst-Case Scenario**\n- **Input:** Alternating large positives and negatives (e.g., `[1, -100, 1, -100, 1]`).\n- **Behavior:** `current_sum` resets frequently but still processes each element once.\n- **Time Complexity:** O(n) (Same as best case).",
        "code": "JAVA CODE:\n\n// BRUTE FORCE:\nclass Solution {\n    public int maxSubArray(int[] nums) {\n        int maxSum = Integer.MIN_VALUE;\n        for (int i = 0; i < nums.length; i++) {\n            int currentSum = 0;\n            for (int j = i; j < nums.length; j++) {\n                currentSum += nums[j];\n                if (currentSum > maxSum) {\n                    maxSum = currentSum;\n                }\n            }\n        }\n        return maxSum;\n    }\n}\n\n// OPTIMAL APPROACH (KADANE'S):\nclass Solution {\n    public int maxSubArray(int[] nums) {\n        int maxSum = nums[0];\n        int currentSum = nums[0];\n        for (int i = 1; i < nums.length; i++) {\n            currentSum = Math.max(nums[i], currentSum + nums[i]);\n            maxSum = Math.max(maxSum, currentSum);\n        }\n        return maxSum;\n    }\n}\n\n\nC++ CODE:\n\n// BRUTE FORCE:\nclass Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        int max_sum = INT_MIN;\n        for (int i = 0; i < nums.size(); i++) {\n            int current_sum = 0;\n            for (int j = i; j < nums.size(); j++) {\n                current_sum += nums[j];\n                if (current_sum > max_sum) {\n                    max_sum = current_sum;\n                }\n            }\n        }\n        return max_sum;\n    }\n};\n\n// OPTIMAL APPROACH (KADANE'S):\nclass Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        int max_sum = nums[0];\n        int current_sum = nums[0];\n        for (int i = 1; i < nums.size(); i++) {\n            current_sum = max(nums[i], current_sum + nums[i]);\n            max_sum = max(max_sum, current_sum);\n        }\n        return max_sum;\n    }\n};"
      },
      {
        "title": "Stock Buy and Sell",
        "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/",
        "difficulty": "Easy"
      },
      {
        "title": "Trapping Rain Water",
        "link": "https://leetcode.com/problems/container-with-most-water/",
        "difficulty": "Hard"
      },
      {
        "title": "Reverse array in groups",
        "description": "## Problem Description\n\nGiven an array nums of positive integers and a group size groupSize, reverse every consecutive segment of groupSize elements in the array.\n\n**Goal:** Perform all modifications in-place without returning a new array.\n\n**Key Rules:**\n- Reverse elements in batches of groupSize\n- If remaining elements < groupSize, reverse the remaining elements\n- If groupSize ≥ array length, reverse entire array\n- Modifications must be done in-place\n\n### Examples:\n\n**Input:** nums = [10, 20, 30, 40, 50, 60], groupSize = 2  \n**Modified Array:** [20, 10, 40, 30, 60, 50]  \n**Explanation:** Reverse first group (10,20) → (20,10), second (30,40) → (40,30), third (50,60) → (60,50)\n\n**Input:** nums = [5, 8, 3, 9, 1], groupSize = 3  \n**Modified Array:** [3, 8, 5, 1, 9]  \n**Explanation:** Reverse first group (5,8,3) → (3,8,5), remaining (9,1) → (1,9)\n\n**Input:** nums = [100, 200, 300], groupSize = 4  \n**Modified Array:** [300, 200, 100]  \n**Explanation:** groupSize > array length → reverse entire array",
        "algorithm": "## Algorithm: Brute-Force = Optimal Approach (Explicit Group Reversal)\n\n**Approach:**\n- Iterate through the array in steps of groupSize\n- For each group:\n  - Calculate the end index of the current group\n  - If the remaining elements are fewer than groupSize, set end index to array end\n  - Reverse the subarray from current index to end index\n\n**Note:**\n- You must check every element anyway\n- The problem requires looking at each number at least once\n- No way to skip elements and still solve it correctly\n- Reversing groups is already very efficient\n- Cannot do fewer operations than we are already doing\n- We are not using extra memory\n- The solution works directly on the original array\n\n**Analogy:**\nImagine flipping sections of a row of books:\n- You must touch each book to flip it\n- You cannot flip them faster than one-by-one\n- Doing it in-place (without another shelf) is already the best way",
        "comparison": [
          {
            "algorithm": "Brute-Force = Optimal Approach",
            "time": "O(n)",
            "space": "O(1)"
          }
        ],
        "analysis": "## Best- and Worst-Case Analysis\n\n### Algorithm: Brute-Force = Optimal Approach (Group Reversal)\n\n**Best-Case Scenario:**\n- **Input:** Array where groupSize = 1 (e.g., nums = [10,20,30], groupSize = 1)\n- **Behavior:** No swaps occur (reversing single elements does nothing)\n- **Time Complexity:** O(n) (must check every element)\n- **Space Complexity:** O(1)\n\n**Worst-Case Scenario:**\n- **Input:** groupSize = 2 with alternating pairs (e.g., nums = [10,20,30,40,50,60], groupSize = 2)\n- **Behavior:** Performs maximum number of swaps (n/2 swaps), each requiring 3 operations (temp storage)\n- **Time Complexity:** O(n)\n- **Space Complexity:** O(1)",
        "code": "JAVA CODE:\n\nclass Solution {\n    public void reverseInGroups(int[] arr, int k) {\n        int n = arr.length;\n        for (int i = 0; i < n; i += k) {\n            int left = i;\n            int right = Math.min(i + k - 1, n - 1);\n            while (left < right) {\n                int temp = arr[left];\n                arr[left] = arr[right];\n                arr[right] = temp;\n                left++;\n                right--;\n            }\n        }\n    }\n}\n\n\nC++ CODE:\n\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass Solution {\npublic:\n    void reverseInGroups(vector<int> &arr, int k) {\n        int n = arr.size();\n        for (int i = 0; i < n; i += k) {\n            int left = i;\n            int right = min(i + k - 1, n - 1);\n            while (left < right) {\n                swap(arr[left], arr[right]);\n                left++;\n                right--;\n            }\n        }\n    }\n};"
      },
      {
        "title": "Minimum Platforms",
        "description": "## Problem Description\n\nGiven two arrays `arrival[]` and `departure[]` representing the schedule of trains at a station, where:\n- `arrival[i]` = when train i arrives\n- `departure[i]` = when train i leaves\n\n### Goal:\nCalculate the minimum number of platforms needed so no train waits for a platform.\n\n### Key Rules:\n- A platform can only serve one train at a time\n- If a train arrives when another is still at the station, a new platform is needed\n- Times are in 24-hour format (e.g., 900 = 9:00 AM, 1430 = 2:30 PM)\n\n### Examples:\n\n**Input:**\narrival = [800, 815, 830, 845]\ndeparture = [830, 845, 900, 915]\n\n**Output:** 2\n\n**Explanation:**\nFrom 8:15-8:30: Two trains present (800-830 and 815-845)\nOther times need only 1 platform\n\n---\n\n**Input:**\narrival = [1000, 1030, 1100]\ndeparture = [1030, 1100, 1130]\n\n**Output:** 1\n\n**Explanation:**\nAll trains depart before the next arrives - perfect scheduling\n\n---\n\n**Input:**\narrival = [700, 730, 800, 830]\ndeparture = [900, 900, 900, 900]\n\n**Output:** 4\n\n**Explanation:**\nAll 4 trains are present from 8:30-9:00 AM",
        "algorithm": "## Approaches:\n\n### 1. Brute-Force Approach (Time Bucket Counting)\n\n**Algorithm:**\n- Find the time range (min arrival to max departure)\n- Create a timeline array covering every minute in this range\n- For each train:\n  - Increment platform count for every minute between its arrival and departure\n- Track the maximum platform count needed at any minute\n- Return the maximum count\n\n---\n\n### 2. Optimal Approach (Event-Based Counting)\n\n**Algorithm:**\n- Sort both arrival and departure arrays\n- Initialize pointers at start of both arrays (i=0, j=0)\n- Initialize platform count and max platforms needed\n- While trains remain in either array:\n  - If next arrival ≤ next departure:\n    - Need a new platform → increment count\n    - Move to next arrival\n  - Else:\n    - A platform freed → decrement count\n    - Move to next departure\n  - Update max platforms needed\n- Return max platforms",
        "comparison": [
          {
            "algorithm": "Brute-Force",
            "time": "O(n × T)",
            "space": "O(T)"
          },
          {
            "algorithm": "Optimal (Event-Based)",
            "time": "O(n log n)",
            "space": "O(1) or O(n)"
          }
        ],
        "analysis": "## Best- and Worst-Case Analysis\n\n### 1. Brute-Force Approach (Time Bucket Counting)\n\n**Best-Case Scenario:**\n- Input: All trains have identical arrival/departure times\n  - Example: arrival = [900, 900, 900], departure = [1000, 1000, 1000]\n- Behavior: Still checks every minute in the time range\n- Time Complexity: O(n × T) (No improvement possible)\n- Space Complexity: O(T)\n\n**Worst-Case Scenario:**\n- Input: Widely spaced schedules covering full day\n  - Example: arrival = [0], departure = [2359]\n- Behavior: Creates timeline of 1440 minutes (24 hours)\n- Time Complexity: O(n × T), T = 1440\n- Space Complexity: O(T)\n\n---\n\n### 2. Optimal Approach (Event-Based Counting)\n\n**Best-Case Scenario:**\n- Input: Perfectly non-overlapping schedules\n  - Example: arrival = [100,300,500], departure = [200,400,600]\n- Behavior: Single pass after sorting\n- Time Complexity: O(n log n)\n- Space Complexity: O(1) (in-place sorting)\n\n**Worst-Case Scenario:**\n- Input: All trains overlap completely\n  - Example: arrival = [100,100,100], departure = [200,200,200]\n- Behavior: Still requires sorting, max platforms = n\n- Time Complexity: O(n log n)\n- Space Complexity: O(1)",
        "code": "JAVA CODE:\n\n// BRUTE FORCE:\nimport java.util.*;\n\nclass Solution {\n    static int findPlatform(int arr[], int dep[]) {\n        int minTime = Arrays.stream(arr).min().getAsInt();\n        int maxTime = Arrays.stream(dep).max().getAsInt();\n        int[] timeline = new int[maxTime - minTime + 2];  // +2 to avoid off-by-one\n\n        for (int i = 0; i < arr.length; i++) {\n            for (int t = arr[i]; t <= dep[i]; t++) {\n                timeline[t - minTime]++;\n            }\n        }\n\n        return Arrays.stream(timeline).max().getAsInt();\n    }\n}\n\n// OPTIMAL APPROACH:\nimport java.util.*;\n\nclass Solution {\n    static int findPlatform(int arr[], int dep[]) {\n        Arrays.sort(arr);\n        Arrays.sort(dep);\n\n        int platforms = 1, maxPlatforms = 1;\n        int i = 1, j = 0;\n        int n = arr.length;\n\n        while (i < n && j < n) {\n            if (arr[i] <= dep[j]) {\n                platforms++;\n                maxPlatforms = Math.max(maxPlatforms, platforms);\n                i++;\n            } else {\n                platforms--;\n                j++;\n            }\n        }\n\n        return maxPlatforms;\n    }\n}\n\n\nC++ CODE:\n\n// BRUTE FORCE:\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass Solution {\npublic:\n    int findPlatform(vector<int>& arr, vector<int>& dep) {\n        int min_time = *min_element(arr.begin(), arr.end());\n        int max_time = *max_element(dep.begin(), dep.end());\n        vector<int> timeline(max_time - min_time + 2, 0);  // +2 to avoid off-by-one\n\n        for (int i = 0; i < arr.size(); i++) {\n            for (int t = arr[i]; t <= dep[i]; t++) {\n                timeline[t - min_time]++;\n            }\n        }\n\n        return *max_element(timeline.begin(), timeline.end());\n    }\n};\n\n// OPTIMAL APPROACH:\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass Solution {\npublic:\n    int findPlatform(vector<int>& arr, vector<int>& dep) {\n        sort(arr.begin(), arr.end());\n        sort(dep.begin(), dep.end());\n\n        int platforms = 1, max_platforms = 1;\n        int i = 1, j = 0;\n        int n = arr.size();\n\n        while (i < n && j < n) {\n            if (arr[i] <= dep[j]) {\n                platforms++;\n                max_platforms = max(max_platforms, platforms);\n                i++;\n            } else {\n                platforms--;\n                j++;\n            }\n        }\n\n        return max_platforms;\n    }\n};"
      }
    ]
  },
  {
    "topicName": "Searching & Sorting",
    "problems": [
      {
        "title": "Merge Sort",
        "description": "## Problem Description\n\nGiven an array `arr[]` with starting index `l` and ending index `r`, sort the array using the Merge Sort algorithm.\n\n**Merge Sort** is a classic **Divide and Conquer** algorithm:\n- **Divide** the array into two halves.\n- **Conquer** by recursively sorting each half.\n- **Combine** the sorted halves into one sorted array.\n\n### Example 1 (Recursive Approach)\n**Input:** `[38, 27, 43, 3, 9, 82, 10]`\n\n**Steps:**\n1. Split into `[38, 27, 43, 3]` and `[9, 82, 10]`\n2. Recursively sort each half\n3. Merge into `[3, 27, 38, 43]` and `[9, 10, 82]`\n4. Final merge: `[3, 9, 10, 27, 38, 43, 82]`\n\n**Output:** `[3, 9, 10, 27, 38, 43, 82]`\n\n### Example 2 (Iterative Approach)\n**Input:** `[5, 1, 4, 2, 8]`\n\n**Steps:**\n1. `size = 1`: Merge pairs → `[1, 5], [2, 4], [8]`\n2. `size = 2`: Merge → `[1, 2, 4, 5]`\n3. `size = 4`: Merge → `[1, 2, 4, 5, 8]`\n\n**Output:** `[1, 2, 4, 5, 8]`",
        "algorithm": "## Approaches\n\n### a. Brute Force Approach (Standard Recursive Merge Sort)\n\n**Steps:**\n1. **Base Case:** If subarray has 0 or 1 element, it's already sorted.\n2. **Divide:**\n   - Find midpoint: `mid = l + (r - l) / 2`\n   - Split into `arr[l..mid]` and `arr[mid+1..r]`\n3. **Conquer:**\n   - Recursively sort both halves\n4. **Merge:**\n   - Use a temporary array to merge the two sorted halves\n   - Compare elements from both halves and insert in order\n   - Copy merged result back to original array\n\n\n### b. Optimal Approach (Iterative Bottom-Up Merge Sort)\n\n**Steps:**\n1. **Initialize:** Start with subarray size `size = 1`\n2. **Loop:** While `size < n`:\n   - For each pair of subarrays of size `size`:\n     - Merge subarrays `[left, mid]` and `[mid+1, right]`\n   - Double `size` after each full pass\n3. **Merge Process:**\n   - Use temporary array\n   - Merge sorted subarrays\n   - Copy result back to original array",
        "analysis": "## Best- and Worst-Case Analysis\n\n### 1. Recursive Merge Sort\n\n**Best Case:**\n- Input: Already sorted array\n- Still performs full divide and merge steps\n- Time: O(n log n), Space: O(n)\n\n**Worst Case:**\n- Input: Reverse sorted array\n- Same process as best case\n- Time: O(n log n), Space: O(n)\n\n\n### 2. Iterative Merge Sort\n\n**Best Case:**\n- Input: Already sorted array\n- All merge passes still happen\n- Time: O(n log n), Space: O(n)\n\n**Worst Case:**\n- Input: Reverse sorted array\n- No optimization during merging\n- Time: O(n log n), Space: O(n)",
        "comparison": [
          {
            "algorithm": "Recursive Merge Sort",
            "time": "O(n log n)",
            "space": "O(n) (stack + temp)"
          },
          {
            "algorithm": "Iterative Merge Sort",
            "time": "O(n log n)",
            "space": "O(n) (temp only)"
          }
        ],
        "code": "JAVA CODE:\n\n// BRUTE FORCE:\nclass Solution {\n    void merge(int arr[], int l, int mid, int r) {\n        int[] temp = new int[r - l + 1];\n        int i = l, j = mid + 1, k = 0;\n        while (i <= mid && j <= r) {\n            if (arr[i] <= arr[j]) {\n                temp[k++] = arr[i++];\n            } else {\n                temp[k++] = arr[j++];\n            }\n        }\n        while (i <= mid) temp[k++] = arr[i++];\n        while (j <= r) temp[k++] = arr[j++];\n        for (int p = 0; p < k; p++) {\n            arr[l + p] = temp[p];\n        }\n    }\n    void mergeSort(int arr[], int l, int r) {\n        if (l >= r) return;\n        int mid = l + (r - l) / 2;\n        mergeSort(arr, l, mid);\n        mergeSort(arr, mid + 1, r);\n        merge(arr, l, mid, r);\n    }\n}\n\n// OPTIMAL APPROACH:\nclass Solution {\n    void merge(int arr[], int l, int mid, int r) {\n        int[] temp = new int[r - l + 1];\n        int i = l, j = mid + 1, k = 0;\n        while (i <= mid && j <= r) {\n            if (arr[i] <= arr[j]) {\n                temp[k++] = arr[i++];\n            } else {\n                temp[k++] = arr[j++];\n            }\n        }\n        while (i <= mid) temp[k++] = arr[i++];\n        while (j <= r) temp[k++] = arr[j++];\n        for (int p = 0; p < k; p++) {\n            arr[l + p] = temp[p];\n        }\n    }\n    void mergeSort(int arr[], int l, int r) {\n        int n = arr.length;\n        for (int size = 1; size < n; size *= 2) {\n            for (int left = 0; left < n; left += 2 * size) {\n                int mid = Math.min(left + size - 1, n - 1);\n                int right = Math.min(left + 2 * size - 1, n - 1);\n                merge(arr, left, mid, right);\n            }\n        }\n    }\n}\n\nC++ CODE:\n\n// BRUTE FORCE:\nclass Solution {\npublic:\n    void merge(vector<int>& arr, int l, int mid, int r) {\n        vector<int> temp(r - l + 1);\n        int i = l, j = mid + 1, k = 0;\n        while (i <= mid && j <= r) {\n            if (arr[i] <= arr[j]) {\n                temp[k++] = arr[i++];\n            } else {\n                temp[k++] = arr[j++];\n            }\n        }\n        while (i <= mid) temp[k++] = arr[i++];\n        while (j <= r) temp[k++] = arr[j++];\n        for (int p = 0; p < k; p++) {\n            arr[l + p] = temp[p];\n        }\n    }\n    void mergeSort(vector<int>& arr, int l, int r) {\n        if (l >= r) return;\n        int mid = l + (r - l) / 2;\n        mergeSort(arr, l, mid);\n        mergeSort(arr, mid + 1, r);\n        merge(arr, l, mid, r);\n    }\n};\n\n// OPTIMAL APPROACH:\nclass Solution {\npublic:\n    void merge(vector<int>& arr, int l, int mid, int r) {\n        vector<int> temp(r - l + 1);\n        int i = l, j = mid + 1, k = 0;\n        while (i <= mid && j <= r) {\n            if (arr[i] <= arr[j]) {\n                temp[k++] = arr[i++];\n            } else {\n                temp[k++] = arr[j++];\n            }\n        }\n        while (i <= mid) temp[k++] = arr[i++];\n        while (j <= r) temp[k++] = arr[j++];\n        for (int p = 0; p < k; p++) {\n            arr[l + p] = temp[p];\n        }\n    }\n    void mergeSort(vector<int>& arr, int l, int r) {\n        int n = arr.size();\n        for (int size = 1; size < n; size *= 2) {\n            for (int left = 0; left < n; left += 2 * size) {\n                int mid = min(left + size - 1, n - 1);\n                int right = min(left + 2 * size - 1, n - 1);\n                merge(arr, left, mid, right);\n            }\n        }\n    }\n};"
      },
      {
        "title": "Quick Sort",
        "description": "## Problem Description\n\nImplement the Quick Sort algorithm using the Divide and Conquer strategy to arrange an integer list `nums[]` in increasing order.\n\nYou are given:\n- An integer list `nums[]`,\n- Two indices: `start` and `end` (both inclusive).\n\nYou must implement two functions:\n- `partition()`\n- `quick_sort()`\n\nUse the **last element** in the subarray as the pivot.\n\n**Conditions:**\n- Elements <= pivot appear before it.\n- Elements > pivot appear after it.\n\n### Examples:\n**Input:** `[8, 5, 2, 9, 1]`\n**Output:** `[1, 2, 5, 8, 9]`\n\n**Input:** `[10, 3, 7, 4, 12, 5]`\n**Output:** `[3, 4, 5, 7, 10, 12]`",
        "algorithm": "## Approaches\n\n### a. Brute Force Approach: Quick Sort (Naive Partition)\n\n**Partitioning:**\n- Use last element as pivot.\n- Create two temporary arrays for elements ≤ pivot and > pivot.\n- Combine: [...left, pivot, ...right].\n\n**Recursion:**\n- Base Case: If `low >= high`, return.\n- Recursively sort left and right:\n  - `quickSort(arr, low, pivotIndex - 1)`\n  - `quickSort(arr, pivotIndex + 1, high)`\n\n### b. Optimal Approach: Quick Sort (Lomuto Partition)\n\n**In-Place Partitioning:**\n- Use last element as pivot.\n- Maintain index `i` for the partition boundary.\n- Swap elements ≤ pivot to the left of `i`.\n\n**Recursion:**\n- Base Case: If `low >= high`, return.\n- Recursively sort left and right:\n  - `quickSort(arr, low, pivotIndex - 1)`\n  - `quickSort(arr, pivotIndex + 1, high)`",
        "analysis": "## Best- and Worst-Case Analysis\n\n### 1. Best Case\n**Condition:** Balanced partitions (pivot is near median).\n**Time Complexity:** O(n log n)\n**Space Complexity:** O(log n)\n\n### 2. Worst Case\n**Condition:** Pivot is always min or max (unbalanced).\n**Examples:** Already sorted `[1,2,3,4,5]`, reverse sorted `[5,4,3,2,1]`\n**Time Complexity:** O(n²)\n**Space Complexity:** O(n)",
        "comparison": [
          {
            "algorithm": "Brute-Force",
            "time": "O(n log n)",
            "worst_time": "O(n²)",
            "space": "O(n)"
          },
          {
            "algorithm": "Optimized (Lomuto)",
            "time": "O(n log n)",
            "worst_time": "O(n²)",
            "space": "O(log n)"
          }
        ],
        "code": "JAVA CODE:\n\n// BRUTE FORCE:\nimport java.util.ArrayList;\nclass Solution {\n    static class PartitionResult {\n        ArrayList<Integer> array;\n        int pivotIndex;\n        PartitionResult(ArrayList<Integer> array, int pivotIndex) {\n            this.array = array;\n            this.pivotIndex = pivotIndex;\n        }\n    }\n    static PartitionResult partition(int arr[], int low, int high) {\n        ArrayList<Integer> left = new ArrayList<>();\n        ArrayList<Integer> right = new ArrayList<>();\n        int pivot = arr[high];\n        for (int i = low; i < high; i++) {\n            if (arr[i] <= pivot) left.add(arr[i]);\n            else right.add(arr[i]);\n        }\n        left.add(pivot);\n        ArrayList<Integer> partitioned = new ArrayList<>(left);\n        partitioned.addAll(right);\n        int pivotIndex = low + left.size() - 1;\n        return new PartitionResult(partitioned, pivotIndex);\n    }\n    static void quickSort(int arr[], int low, int high) {\n        if (low >= high) return;\n        PartitionResult result = partition(arr, low, high);\n        ArrayList<Integer> partitioned = result.array;\n        int pivotIndex = result.pivotIndex;\n        for (int i = low; i <= high; i++) {\n            arr[i] = partitioned.get(i - low);\n        }\n        quickSort(arr, low, pivotIndex - 1);\n        quickSort(arr, pivotIndex + 1, high);\n    }\n}\n\n// OPTIMAL APPROACH:\nclass Solution {\n    static int partition(int arr[], int low, int high) {\n        int pivot = arr[high];\n        int i = low - 1;\n        for (int j = low; j < high; j++) {\n            if (arr[j] <= pivot) {\n                i++;\n                int temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n            }\n        }\n        int temp = arr[i + 1];\n        arr[i + 1] = arr[high];\n        arr[high] = temp;\n        return i + 1;\n    }\n    static void quickSort(int arr[], int low, int high) {\n        if (low < high) {\n            int pivotIndex = partition(arr, low, high);\n            quickSort(arr, low, pivotIndex - 1);\n            quickSort(arr, pivotIndex + 1, high);\n        }\n    }\n}\n\n\nC++ CODE:\n\n// BRUTE FORCE:\n#include <vector>\nusing namespace std;\nclass Solution {\npublic:\n    vector<int> partition(vector<int>& arr, int low, int high, int& pivotIndex) {\n        vector<int> left, right;\n        int pivot = arr[high];\n        for (int i = low; i < high; i++) {\n            if (arr[i] <= pivot) left.push_back(arr[i]);\n            else right.push_back(arr[i]);\n        }\n        left.push_back(pivot);\n        vector<int> partitioned = left;\n        partitioned.insert(partitioned.end(), right.begin(), right.end());\n        pivotIndex = low + left.size() - 1;\n        return partitioned;\n    }\n    void quickSort(vector<int>& arr, int low, int high) {\n        if (low >= high) return;\n        int pivotIndex;\n        vector<int> partitioned = partition(arr, low, high, pivotIndex);\n        for (int i = low; i <= high; i++) arr[i] = partitioned[i - low];\n        quickSort(arr, low, pivotIndex - 1);\n        quickSort(arr, pivotIndex + 1, high);\n    }\n};\n\n// OPTIMAL APPROACH:\n#include <vector>\nusing namespace std;\nclass Solution {\npublic:\n    int partition(vector<int>& arr, int low, int high) {\n        int pivot = arr[high];\n        int i = low - 1;\n        for (int j = low; j < high; j++) {\n            if (arr[j] <= pivot) {\n                i++;\n                swap(arr[i], arr[j]);\n            }\n        }\n        swap(arr[i + 1], arr[high]);\n        return i + 1;\n    }\n    void quickSort(vector<int>& arr, int low, int high) {\n        if (low < high) {\n            int pivotIndex = partition(arr, low, high);\n            quickSort(arr, low, pivotIndex - 1);\n            quickSort(arr, pivotIndex + 1, high);\n        }\n    }\n};"
      },
      {
        "title": "Allocate minimum number of pages",
        "description": "## Problem Description\n\nGiven an array `num[i]` where each element represents the number of pages in the ith book. Also given an integer `k` representing the number of students.\n\n**Objective:** Allocate books contiguously among `k` students such that:\n- Each student gets at least one book\n- Books are assigned in order\n- No book is split\n- Minimize the maximum number of pages assigned to any student\n\nIf `k > num.length`, return `-1` (invalid case).\n\n### Example 1\n**Input:** `num = [10, 20, 30, 40], k = 2`\n\n**Explanation:**\nPossible splits:\n- [10] and [20, 30, 40] → max = 90\n- [10, 20] and [30, 40] → max = 70\n- [10, 20, 30] and [40] → max = 60\n\n**Optimal Split:** [10, 20, 30] and [40] → **Output = 60**\n\n### Example 2\n**Input:** `num = [5, 10, 15], k = 4`\n\n**Explanation:**\n`k > num.length` → **Output = -1** (invalid case)",
        "algorithm": "## Approaches\n\n### a. Brute Force Approach (Recursive Backtracking)\n\nThis approach tries all possible ways to divide the books into `k` contiguous parts and selects the allocation with the minimum possible maximum pages assigned to any student.\n\n**Steps:**\n1. **Check Validity:**\n   - If `k > num.length`, return `-1`.\n\n2. **Recursive Splitting:**\n   - For each possible split point `i` (from 1 to `n - k + 1`):\n     - Assign `num[0..i-1]` to the first student.\n     - Recursively assign the remaining books `num[i..n-1]` to `k - 1` students.\n\n3. **Compute Maximum Pages:**\n   - For each split, calculate the maximum pages assigned to any student.\n\n4. **Return Minimum of Maximums:**\n   - The final result is the minimum among all maximums from each valid allocation.\n\n\n### b. Optimal Approach (Binary Search + Greedy Allocation)\n\nThis approach uses binary search to find the minimum feasible maximum number of pages that can be allocated to a student, using a greedy strategy to check feasibility.\n\n**Steps:**\n1. **Edge Cases:**\n   - If `k > num.length`, return `-1`.\n   - If `k == 1`, return `sum(num)`.\n\n2. **Binary Search Setup:**\n   - `low = max(num)` → minimum possible maximum.\n   - `high = sum(num)` → maximum possible maximum.\n\n3. **Binary Search Execution:**\n   - While `low < high`:\n     - Compute `mid = low + (high - low) / 2`.\n     - Use greedy allocation to check if it is possible to assign books such that no student gets more than `mid` pages.\n     - If the number of required students is `≤ k`, try a smaller `mid` (set `high = mid`).\n     - Otherwise, increase `mid` (set `low = mid + 1`).\n\n4. **Return `low`:**\n   - This will be the smallest feasible maximum number of pages.",
        "analysis": "## Best- and Worst-Case Analysis\n\n### 1. Brute-Force (Recursive Backtracking) Approach\n\n1. **Best-Case:**\n  - Input: `k = 1`\n  - Behavior: Return `sum(num)` directly\n  - Time: O(1), Space: O(1)\n\n2. **Worst-Case:**\n  - Input: All books have equal pages (e.g., `[10, 10, 10, 10], k = 2`)\n  - Must explore all possible splits → C(n-1, k-1)\n  - Time: O(kⁿ), Space: O(n)\n\n### 2. Optimal (Binary Search + Greedy) Approach\n\n1. **Best-Case:**\n  - Input: `k = n` (1 book per student)\n  - Behavior: Greedy check passes in one go\n  - Time: O(n), Space: O(1)\n\n2. **Worst-Case:**\n  - Input: `[1, 1, ..., 1000], k = 2`\n  - Binary search takes `O(log(sum))` steps, each `O(n)`\n  - Time: O(n log(sum)), Space: O(1)",
        "comparison": [
          {
            "algorithm": "Brute-Force (Recursive)",
            "time": "O(kⁿ)",
            "space": "O(n)"
          },
          {
            "algorithm": "Optimal (Binary Search + Greedy)",
            "time": "O(n log(sum(num)))",
            "space": "O(1)"
          }
        ],

        "code": "JAVA CODE:\n\n// BRUTE FORCE:\nclass Solution {\n    private int helper(int[] arr, int k, int start) {\n        if (k == 1) {\n            int sum = 0;\n            for (int i = start; i < arr.length; i++) sum += arr[i];\n            return sum;\n        }\n        int minMax = Integer.MAX_VALUE;\n        int sum = 0;\n        for (int i = start; i <= arr.length - k; i++) {\n            sum += arr[i];\n            int res = helper(arr, k - 1, i + 1);\n            minMax = Math.min(minMax, Math.max(sum, res));\n        }\n        return minMax;\n    }\n    public static int findPages(int[] arr, int k) {\n        if (k > arr.length) return -1;\n        Solution sol = new Solution();\n        return sol.helper(arr, k, 0);\n    }\n}\n\n\n// OPTIMAL APPROACH:\nimport java.util.Arrays;\n\nclass Solution {\n    private boolean isPossible(int[] arr, int k, int mid) {\n        int students = 1;\n        int sum = 0;\n        for (int i = 0; i < arr.length; i++) {\n            if (sum + arr[i] > mid) {\n                students++;\n                sum = arr[i];\n                if (students > k) return false;\n            } else {\n                sum += arr[i];\n            }\n        }\n        return true;\n    }\n\n    public static int findPages(int[] arr, int k) {\n        if (k > arr.length) return -1;\n        int low = Arrays.stream(arr).max().getAsInt();\n        int high = Arrays.stream(arr).sum();\n        int res = -1;\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            Solution sol = new Solution();\n            if (sol.isPossible(arr, k, mid)) {\n                res = mid;\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return res;\n    }\n}\n\n\n\nC++ CODE:\n\n// BRUTE FORCE:\nclass Solution {\npublic:\n    int helper(vector<int>& arr, int k, int start) {\n        if (k == 1) return accumulate(arr.begin() + start, arr.end(), 0);\n        int minMax = INT_MAX;\n        int sum = 0;\n        for (int i = start; i < arr.size() - k + 1; i++) {\n            sum += arr[i];\n            int res = helper(arr, k - 1, i + 1);\n            minMax = min(minMax, max(sum, res));\n        }\n        return minMax;\n    }\n\n    int findPages(vector<int>& arr, int k) {\n        if (k > arr.size()) return -1;\n        return helper(arr, k, 0);\n    }\n};\n\n\n// OPTIMAL APPROACH:\nclass Solution {\npublic:\n    bool isPossible(vector<int>& arr, int k, int mid) {\n        int students = 1;\n        int sum = 0;\n        for (int i = 0; i < arr.size(); i++) {\n            if (sum + arr[i] > mid) {\n                students++;\n                sum = arr[i];\n                if (students > k) return false;\n            } else {\n                sum += arr[i];\n            }\n        }\n        return true;\n    }\n\n    int findPages(vector<int>& arr, int k) {\n        if (k > arr.size()) return -1;\n        int low = *max_element(arr.begin(), arr.end());\n        int high = accumulate(arr.begin(), arr.end(), 0);\n        int res = -1;\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            if (isPossible(arr, k, mid)) {\n                res = mid;\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return res;\n    }\n};"
      },
      {
        "title": "Merge 2 sorted arrays",
        "description": "## Problem Description\n\nGiven two sorted arrays:\n- `nums1` of length `m + n`, where the first `m` elements are valid and the rest are 0 placeholders.\n- `nums2` of length `n`.\n\n**Goal:** Merge `nums2` into `nums1` in-place, so that `nums1` becomes a single sorted array.\n\n### Example 1:\n**Input:** nums1 = [1, 2, 3, 0, 0, 0], m = 3, nums2 = [2, 5, 6], n = 3\n**Output:** [1, 2, 2, 3, 5, 6]\n**Explanation:**\n- Merge from end:\n  - Compare 3 (nums1) and 6 (nums2) → place 6 at end.\n  - Compare 3 and 5 → place 5.\n  - Compare 3 and 2 → place 3.\n  - Compare 2 and 2 → place 2.\n  - Copy remaining 1 from nums1.\n\n### Example 2:\n**Input:** nums1 = [4, 0, 0, 0], m = 1, nums2 = [1, 2, 3], n = 3\n**Output:** [1, 2, 3, 4]\n**Explanation:**\n- Merge from end: nums2 exhausts first, so copy all its elements to nums1.",
        "algorithm": "## Approaches\n\n### a. Brute-Force Approach (Append and Sort)\n**Steps:**\n- Append nums2 to nums1 starting from index `m`.\n- Sort the entire `nums1` array.\n\n### b. Optimal Approach (Two-Pointer Merge from End)\n**Steps:**\n1. Initialize:\n   - i = m - 1 (last valid element in nums1)\n   - j = n - 1 (last element in nums2)\n   - k = m + n - 1 (last position in nums1)\n\n2. While i >= 0 and j >= 0:\n   - If nums1[i] > nums2[j]: set nums1[k] = nums1[i]; decrement i\n   - Else: set nums1[k] = nums2[j]; decrement j\n   - Decrement k\n\n3. Copy remaining nums2 elements (if any) to nums1:\n   - While j >= 0: nums1[k--] = nums2[j--]",
        "analysis": "## Best- and Worst-Case Analysis\n\n### Brute-Force (Append + Sort)\n**Best-Case:**\n- Input: nums2 is empty\n- Behavior: No appending or sorting needed\n- Time Complexity: O(1), Space: O(1)\n\n**Worst-Case:**\n- Input: Reverse-sorted arrays\n- Behavior: Full append and sorting required\n- Time Complexity: O((m + n) log(m + n)), Space: O(1)\n\n---\n\n### Optimal (Two-Pointer Merge)\n**Best-Case:**\n- Input: All elements in nums2 are smaller than nums1\n- Behavior: Direct overwrite from start\n- Time Complexity: O(n), Space: O(1)\n\n**Worst-Case:**\n- Input: Interleaved elements\n- Behavior: Compare all elements\n- Time Complexity: O(m + n), Space: O(1)",
        "comparison": [
          {
            "algorithm": "Brute-Force (Append + Sort)",
            "time": "O((m + n) log(m + n))",
            "space": "O(1)"
          },
          {
            "algorithm": "Optimal (Two-Pointer Merge)",
            "time": "O(m + n)",
            "space": "O(1)"
          }
        ],
        "code": "JAVA CODE:\n\n// BRUTE FORCE:\nimport java.util.Arrays;\n\nclass Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        // Copy nums2 into nums1's end\n        for (int i = 0; i < n; i++) {\n            nums1[m + i] = nums2[i];\n        }\n        // Sort the entire nums1\n        Arrays.sort(nums1);\n    }\n}\n\n// OPTIMAL APPROACH:\nclass Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        int i = m - 1;  // Last element of nums1's valid part\n        int j = n - 1;  // Last element of nums2\n        int k = m + n - 1;  // Last position of nums1\n\n        // Merge from the end\n        while (i >= 0 && j >= 0) {\n            if (nums1[i] > nums2[j]) {\n                nums1[k--] = nums1[i--];\n            } else {\n                nums1[k--] = nums2[j--];\n            }\n        }\n\n        // Copy remaining elements from nums2 if any\n        while (j >= 0) {\n            nums1[k--] = nums2[j--];\n        }\n    }\n}\n\n\nC++ CODE:\n\n// BRUTE FORCE:\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass Solution {\npublic:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n        // Copy nums2 into nums1's end\n        for (int i = 0; i < n; i++) {\n            nums1[m + i] = nums2[i];\n        }\n        // Sort the entire nums1\n        sort(nums1.begin(), nums1.end());\n    }\n};\n\n// OPTIMAL APPROACH:\nclass Solution {\npublic:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n        int i = m - 1;  // Last element of nums1's valid part\n        int j = n - 1;  // Last element of nums2\n        int k = m + n - 1;  // Last position of nums1\n\n        // Merge from the end\n        while (i >= 0 && j >= 0) {\n            if (nums1[i] > nums2[j]) {\n                nums1[k--] = nums1[i--];\n            } else {\n                nums1[k--] = nums2[j--];\n            }\n        }\n\n        // Copy remaining elements from nums2 if any\n        while (j >= 0) {\n            nums1[k--] = nums2[j--];\n        }\n    }\n};"
      },
      {
        "title": "kth smallest element",
        "description": "## Problem Description\n\nGiven an n x n matrix where each row and each column are sorted in ascending order.\n\n**Goal:** Return the kth smallest element in the matrix.\n\n**Note:**\n- This is not the kth distinct element.\n- You must find a solution with memory complexity better than O(n²).\n\n### Example 1:\n**Input:** matrix = [[1, 5, 9], [10, 11, 13], [12, 13, 15]], k = 8\n\n**Output:** 13\n\n**Explanation:** All elements in sorted order: [1, 5, 9, 10, 11, 12, 13, 13, 15].\nThe 8th smallest = 13\n\n### Example 2:\n**Input:** matrix = [[-5]], k = 1\n\n**Output:** -5",
        "algorithm": "## Approaches:\n\n### a. Brute Force Approach (Flatten and Sort)\n\n**Approach:**\n- Flatten the matrix into a 1D array.\n- Sort the array.\n- Return the k-th element.\n\n**Steps:**\n1. Flatten Matrix:\n   - Traverse all elements and store them in a list.\n2. Sort the List:\n   - Use standard sorting.\n3. Return k-th Element:\n   - Return list.get(k-1) (0-based indexing).\n\n---\n\n### b. Optimal Approach (Binary Search on Matrix)\n\n**Approach:**\n- Binary Search on Possible Values:\n  - The smallest element is matrix[0][0], and the largest is matrix[n-1][n-1].\n  - Perform binary search between these bounds.\n- Count Elements ≤ Mid:\n  - For each mid, count how many elements are ≤ mid by traversing rows and columns efficiently.\n- Adjust Search Range:\n  - If count < k, search the higher half.\n  - Else, search the lower half.\n- Return the Smallest Valid Value:\n  - The loop ends when low == high, giving the k-th smallest.\n\n**Steps:**\n1. Initialize low and high:\n   - low = matrix[0][0], high = matrix[n-1][n-1].\n2. Binary Search Loop:\n   - While low < high:\n     - mid = low + (high - low) / 2.\n     - Count elements ≤ mid.\n     - If count < k, set low = mid + 1.\n     - Else, set high = mid.\n3. Return low: The k-th smallest element.",
        "analysis": "## Best- and Worst-Case Analysis\n\n### Algorithm 1: Brute-Force (Flatten + Sort)\n\n**Best Case:**\n- Scenario: The matrix is already flattened in sorted order.\n- Time: O(n² log n²)\n- Space: O(n²)\n\n**Worst Case:**\n- Scenario: The matrix is large and needs sorting.\n- Time: O(n² log n²)\n- Space: O(n²)\n\n---\n\n### Algorithm 2: Optimal (Binary Search on Matrix)\n\n**Best Case:**\n- Scenario: k is near the first or last element.\n- Time: O(n log(max - min)) (fewer iterations)\n- Space: O(1)\n\n**Worst Case:**\n- Scenario: k ≈ n²/2\n- Time: O(n log(max - min)) (full binary search depth)\n- Space: O(1)",
        "comparison": [
          {
            "algorithm": "Brute-Force (Flatten + Sort)",
            "time": "O(n² log n)",
            "space": "O(n²)"
          },
          {
            "algorithm": "Optimal (Binary Search on Matrix)",
            "time": "O(n log(max - min))",
            "space": "O(1)"
          }
        ],
        "code": "JAVA CODE:\n\n// BRUTE FORCE:\nimport java.util.*;\nclass Solution {\n    public int kthSmallest(int[][] matrix, int k) {\n        ArrayList<Integer> flattened = new ArrayList<>();\n        for (int[] row : matrix) {\n            for (int num : row) {\n                flattened.add(num);\n            }\n        }\n        Collections.sort(flattened);\n        return flattened.get(k - 1);\n    }\n}\n\n// OPTIMAL APPROACH:\nclass Solution {\n    public int kthSmallest(int[][] matrix, int k) {\n        int n = matrix.length;\n        int low = matrix[0][0];\n        int high = matrix[n-1][n-1];\n\n        while (low < high) {\n            int mid = low + (high - low) / 2;\n            int count = 0, j = n - 1;\n            for (int i = 0; i < n; i++) {\n                while (j >= 0 && matrix[i][j] > mid) j--;\n                count += (j + 1);\n            }\n            if (count < k) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n}\n\nC++ CODE:\n\n// BRUTE FORCE:\n#include <vector>\n#include <algorithm>\nclass Solution {\npublic:\n    int kthSmallest(std::vector<std::vector<int>>& matrix, int k) {\n        std::vector<int> flattened;\n        for (const auto& row : matrix) {\n            flattened.insert(flattened.end(), row.begin(), row.end());\n        }\n        std::sort(flattened.begin(), flattened.end());\n        return flattened[k - 1];\n    }\n};\n\n// OPTIMAL APPROACH:\nclass Solution {\npublic:\n    int kthSmallest(std::vector<std::vector<int>>& matrix, int k) {\n        int n = matrix.size();\n        int low = matrix[0][0];\n        int high = matrix[n-1][n-1];\n\n        while (low < high) {\n            int mid = low + (high - low) / 2;\n            int count = 0;\n            int j = n - 1;\n\n            for (int i = 0; i < n; i++) {\n                while (j >= 0 && matrix[i][j] > mid) j--;\n                count += (j + 1);\n            }\n\n            if (count < k) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n};"
      }
    ]
  },
  {
    "topicName": "Strings",
    "problems": [
      {
        "title": "Find the first repeating character"
      },
      {
        "title": "Reverse word in a string",
        "description": "Given an input string str, reverse the order of the words.\n\nA word is defined as a sequence of non-space characters. The words in str will be separated by at least one space.\n\nReturn a string of the words in reverse order concatenated by a single space. Note that str may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces. str must have at least one word.\n\n**Examples:**\n1) Input: str = \"The weather   is so   pleasant right   now    \"\n   Output: \"now right pleasant so is weather The\"",
        "algorithm": "**Step 1: Skip Leading Spaces**\n- Initialize an index i = 0\n- While i < n and str[i] == ' ', increment i\n- Set this as the new starting index\n\n**Step 2: Extract Words**\n- Initialize an empty list words[]\n- While i < n:\n  - Initialize empty string word = \"\"\n  - While i < n and str[i] != ' ', append str[i] to word and increment i\n  - If word is not empty, append word to words[]\n  - While i < n and str[i] == ' ', increment i (skip multiple spaces)\n\n**Step 3: Reverse the Words List**\n- Use two pointers: left = 0, right = words.length - 1\n- While left < right, swap words[left] and words[right], increment left, decrement right\n\n**Step 4: Join Words with Single Space**\n- Initialize result = \"\"\n- Loop through words and join them using a single space\n\n**Step 5: Return Result**\n- Return the final result string",
        "analysis": "**A. BEST CASE ANALYSIS**\n- **Scenario**: The string has one word only and no extra spaces\n- **Example**: str = \"hello\"\n- **Time Complexity**: O(n)\n\n**B. WORST CASE ANALYSIS**\n- **Scenario**: String has maximum length, multiple words, and lots of extra spaces\n- **Example**: \"The weather   is so   pleasant right   now    \"\n- **Time Complexity**: O(n)",
        "comparison": "Step\t\tBest Case\t\tWorst Case\nTime Complexity\tO(n)\t\t\tO(n)\nSpace Complexity\tO(n)\t\t\tO(n)",
        "code": "JAVA CODE:\nimport java.util.Scanner;\n\npublic class Solution {\n    public static String reverseWords(String s) {\n        // Trim and split by one or more spaces\n        String[] words = s.trim().split(\"\\\\s+\");\n        StringBuilder reversed = new StringBuilder();\n        for (int i = words.length - 1; i >= 0; i--) {\n            reversed.append(words[i]);\n            if (i != 0) reversed.append(\" \");\n        }\n        return reversed.toString();\n    }\n\n    public static void main(String[] args) {\n        String input = \"The weather   is so   pleasant right   now    \";\n        String output = reverseWords(input);\n        System.out.println(output);\n    }\n}\n\n\nC++ CODE:\n#include <iostream>\n#include <sstream>\n#include <vector>\nusing namespace std;\n\nstring reverseWords(const string& s) {\n    vector<string> words;\n    string word;\n    stringstream ss(s);\n    while (ss >> word) {\n        words.push_back(word);\n    }\n    string reversed;\n    for (int i = words.size() - 1; i >= 0; --i) {\n        reversed += words[i];\n        if (i != 0) reversed += \" \";\n    }\n    return reversed;\n}\n\nint main() {\n    string input = \"The weather   is so   pleasant right   now    \";\n    string output = reverseWords(input);\n    cout << output << endl;\n    return 0;\n}"
      },
      {
        "title": "Anagram",
        "description": "## Problem Description\n\nGiven two strings `str1` and `str2`, determine if they are anagrams of each other. An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n\n### Examples:\n**Input:** str1 = \"listen\", str2 = \"silent\"\n\n**Output:** true\n\n**Explanation:** Both strings contain the same letters (e, i, l, n, s, t) in different orders.\n\n**Input:** str1 = \"hello\", str2 = \"world\"\n\n**Output:** false\n\n**Explanation:** The strings contain different sets of letters.",
        "algorithm": "## Approaches:\n\n### 1. Brute-Force Approach (Sort and Compare)\n\n**Steps:**\n- If lengths of str1 and str2 are not equal, return false.\n- If both strings are empty, return true.\n- Convert both strings to character arrays.\n- Sort the arrays in ascending order.\n- Compare the sorted arrays. If identical, return true; otherwise, return false.\n\n---\n\n### 2. Optimal Approach (Frequency Count)\n\n**Steps:**\n- If lengths of str1 and str2 are not equal, return false.\n- If both strings are empty, return true.\n- Initialize a fixed-size array (26 for lowercase or 256 for ASCII) filled with zeros.\n- Traverse str1 and increment frequency count for each character.\n- Traverse str2 and decrement frequency count for each character.\n- If any value in the array is non-zero, return false; else, return true.\n- Alternatively, use a hash map for Unicode character support.",
        "analysis": "## Best- and Worst-Case Analysis\n\n### 1. Brute-Force (Sorting) Approach\n\n**Best-Case:**\n- Input: str1 = \"abc\", str2 = \"abc\"\n- Still requires full sorting.\n- Time Complexity: O(n log n)\n- Space Complexity: O(n)\n\n**Worst-Case:**\n- Input: str1 = \"abc\", str2 = \"xyz\"\n- Full sort and compare.\n- Time Complexity: O(n log n)\n- Space Complexity: O(n)\n\n---\n\n### 2. Optimal (Frequency Count) Approach\n\n**Best-Case:**\n- Input: str1 = \"a\", str2 = \"ab\"\n- Early exit on length mismatch.\n- Time Complexity: O(1)\n- Space Complexity: O(1) (array) or O(k) (hash map)\n\n**Worst-Case:**\n- Input: str1 = \"listen\", str2 = \"silent\"\n- Full traversal.\n- Time Complexity: O(n)\n- Space Complexity: O(1) (array) or O(k) (hash map)",
        "comparison": [
          {
            "algorithm": "Brute-Force (Sorting)",
            "time": "O(n log n)",
            "space": "O(n) or O(1) if in-place"
          },
          {
            "algorithm": "Optimal (Frequency Count)",
            "time": "O(n)",
            "space": "O(1) for ASCII or O(k) for Unicode"
          }
        ],
        "code": "JAVA CODE:\n\n// BRUTE FORCE:\nimport java.util.Arrays;\n\nclass Solution {\n    public boolean isAnagram(String s, String t) {\n        if (s.length() != t.length()) {\n            return false;\n        }\n        char[] sChars = s.toCharArray();\n        char[] tChars = t.toCharArray();\n        Arrays.sort(sChars);\n        Arrays.sort(tChars);\n        return Arrays.equals(sChars, tChars);\n    }\n}\n\n// OPTIMAL APPROACH:\nclass Solution {\n    public boolean isAnagram(String s, String t) {\n        if (s.length() != t.length()) {\n            return false;\n        }\n        int[] freq = new int[26];\n        for (int i = 0; i < s.length(); i++) {\n            freq[s.charAt(i) - 'a']++;\n            freq[t.charAt(i) - 'a']--;\n        }\n        for (int count : freq) {\n            if (count != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n\nC++ CODE:\n\n// BRUTE FORCE:\n#include <algorithm>\n#include <string>\n\nclass Solution {\npublic:\n    bool isAnagram(std::string s, std::string t) {\n        if (s.length() != t.length()) {\n            return false;\n        }\n        std::sort(s.begin(), s.end());\n        std::sort(t.begin(), t.end());\n        return s == t;\n    }\n};\n\n// OPTIMAL APPROACH:\n#include <vector>\n#include <string>\n\nclass Solution {\npublic:\n    bool isAnagram(std::string s, std::string t) {\n        if (s.length() != t.length()) {\n            return false;\n        }\n        std::vector<int> freq(26, 0);\n        for (int i = 0; i < s.length(); i++) {\n            freq[s[i] - 'a']++;\n            freq[t[i] - 'a']--;\n        }\n        for (int count : freq) {\n            if (count != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n};"
      },
      {
        "title": "Remove Duplicates",
        "description": "## Problem Description\n\nGiven a string `str`, remove duplicate letters so that each letter appears exactly once. Among all possible results that meet this condition, return the one that comes first in alphabetical order.\n\n**Note:** `str` consists of lowercase letters only.\n\n### Example:\n**Input:** str = \"Demigoddessship\"\n**Output:** \"deghimops\"",
        "algorithm": "## Approaches:\n\n### a. Brute-Force Approach (Permutations)\n\n**Approach:**\n- Generate all possible permutations of the string with unique characters.\n- Filter valid permutations (containing all unique characters from original string).\n- Select the lexicographically smallest valid permutation.\n\n**Steps:**\n1. Generate Power Set:\n   - Create all possible subsets of characters.\n2. Filter Valid Permutations:\n   - Keep only subsets that contain all unique characters of `str`.\n3. Sort and Select:\n   - Sort all valid permutations lexicographically.\n   - Return the first one.\n\n---\n\n### b. Optimal Approach (Stack and Greedy)\n\n**Approach:**\n- Count character frequencies (to know when we can skip characters).\n- Use a stack to build the result:\n  - Maintain lexicographical order.\n  - Ensure each character appears exactly once.\n  - Track visited characters to avoid duplicates.\n\n**Steps:**\n1. Count frequencies of each character in `str`.\n2. Initialize:\n   - Empty stack.\n   - Visited set (to track characters in stack).\n3. Process each character:\n   - Decrement frequency count.\n   - If already in stack, skip.\n   - While current character < stack top AND stack top appears later:\n     - Remove from stack (we can add it back later).\n   - Push current character to stack.\n4. Return stack contents as the result.",
        "analysis": "## Best- and Worst-Case Analysis\n\n### Algorithm 1: Brute-Force Approach (Permutations)\n\n**Best-Case Scenario:**\n- Input: String with all unique characters (e.g., \"abc\").\n- Behavior:\n  - No duplicates to remove → returns input as-is.\n- Time Complexity: O(n!) (still generates all permutations).\n- Space Complexity: O(n!) (stores all permutations).\n\n**Worst-Case Scenario:**\n- Input: String with all identical characters (e.g., \"aaaaa\").\n- Behavior:\n  - Only one unique character → returns \"a\".\n  - Still generates all permutations (redundant work).\n- Time Complexity: O(n!).\n- Space Complexity: O(n!).\n\n**Key Issue:**\n- Brute-force is impractical for n > 10 due to factorial complexity.\n\n---\n\n### Algorithm 2: Optimal Approach (Stack + Greedy)\n\n**Best-Case Scenario:**\n- Input: Already lexicographically ordered with no duplicates (e.g., \"abcdef\").\n- Behavior:\n  - Each character is pushed to the stack once.\n  - No backtracking (while loop never executes).\n- Time Complexity: O(n) (single pass).\n- Space Complexity: O(1) (fixed-size alphabet tracking).\n\n**Worst-Case Scenario:**\n- Input: Reverse lexicographical order with duplicates (e.g., \"fedcbaa\").\n- Behavior:\n  - Requires backtracking for every character.\n  - while loop triggers for each character to maintain order.\n- Time Complexity: O(n) (each character processed at most twice).\n- Space Complexity: O(1) (stack size ≤ 26).",
        "comparison": [
          {
            "algorithm": "Brute-Force (Permutations)",
            "time": "O(n!)",
            "space": "O(n!)"
          },
          {
            "algorithm": "Optimal (Stack + Greedy)",
            "time": "O(n)",
            "space": "O(1)"
          }
        ],
        "code": "JAVA CODE:\n\n// BRUTE FORCE:\nimport java.util.*;\n\nclass Solution {\n    public String removeDuplicateLetters(String s) {\n        Set<Character> unique = new HashSet<>();\n        for (char c : s.toCharArray()) unique.add(c);\n\n        List<String> permutations = new ArrayList<>();\n        generatePermutations(\"\", new ArrayList<>(unique), permutations);\n\n        List<String> valid = new ArrayList<>();\n        for (String perm : permutations) {\n            if (isValid(perm, s)) valid.add(perm);\n        }\n\n        Collections.sort(valid);\n        return valid.isEmpty() ? \"\" : valid.get(0);\n    }\n\n    private void generatePermutations(String current, List<Character> chars, List<String> result) {\n        if (chars.isEmpty()) {\n            result.add(current);\n            return;\n        }\n        for (int i = 0; i < chars.size(); i++) {\n            char c = chars.get(i);\n            List<Character> remaining = new ArrayList<>(chars);\n            remaining.remove(i);\n            generatePermutations(current + c, remaining, result);\n        }\n    }\n\n    private boolean isValid(String perm, String s) {\n        int index = 0;\n        for (char c : perm.toCharArray()) {\n            index = s.indexOf(c, index);\n            if (index == -1) return false;\n            index++;\n        }\n        return true;\n    }\n}\n\n// OPTIMAL APPROACH:\nimport java.util.*;\n\nclass Solution {\n    public String removeDuplicateLetters(String s) {\n        int[] count = new int[26];\n        boolean[] inStack = new boolean[26];\n        Deque<Character> stack = new ArrayDeque<>();\n\n        for (char c : s.toCharArray()) count[c - 'a']++;\n\n        for (char c : s.toCharArray()) {\n            count[c - 'a']--;\n            if (inStack[c - 'a']) continue;\n\n            while (!stack.isEmpty() && c < stack.peek() && count[stack.peek() - 'a'] > 0) {\n                inStack[stack.pop() - 'a'] = false;\n            }\n\n            stack.push(c);\n            inStack[c - 'a'] = true;\n        }\n\n        StringBuilder sb = new StringBuilder();\n        while (!stack.isEmpty()) sb.append(stack.removeLast());\n        return sb.toString();\n    }\n}\n\n\nC++ CODE:\n\n// BRUTE FORCE:\n#include <vector>\n#include <string>\n#include <unordered_set>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    string removeDuplicateLetters(string s) {\n        unordered_set<char> unique(s.begin(), s.end());\n        vector<char> chars(unique.begin(), unique.end());\n        sort(chars.begin(), chars.end());\n\n        vector<string> permutations;\n        generatePermutations(\"\", chars, permutations);\n\n        vector<string> valid;\n        for (const string& perm : permutations) {\n            if (isValid(perm, s)) valid.push_back(perm);\n        }\n\n        sort(valid.begin(), valid.end());\n        return valid.empty() ? \"\" : valid[0];\n    }\n\nprivate:\n    void generatePermutations(string current, vector<char> chars, vector<string>& result) {\n        if (chars.empty()) {\n            result.push_back(current);\n            return;\n        }\n        for (size_t i = 0; i < chars.size(); i++) {\n            char c = chars[i];\n            vector<char> remaining = chars;\n            remaining.erase(remaining.begin() + i);\n            generatePermutations(current + c, remaining, result);\n        }\n    }\n\n    bool isValid(const string& perm, const string& s) {\n        size_t index = 0;\n        for (char c : perm) {\n            index = s.find(c, index);\n            if (index == string::npos) return false;\n            index++;\n        }\n        return true;\n    }\n};\n\n\n// OPTIMAL APPROACH:\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <deque>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    string removeDuplicateLetters(string s) {\n        unordered_map<char, int> count;\n        unordered_set<char> inStack;\n        deque<char> stack;\n\n        for (char c : s) count[c]++;\n\n        for (char c : s) {\n            count[c]--;\n            if (inStack.count(c)) continue;\n\n            while (!stack.empty() && c < stack.back() && count[stack.back()] > 0) {\n                inStack.erase(stack.back());\n                stack.pop_back();\n            }\n\n            stack.push_back(c);\n            inStack.insert(c);\n        }\n\n        return string(stack.begin(), stack.end());\n    }\n};"
      },
      {
        "title": "Implement the strstr function",
        "description": "## Problem Description\n\nProblem Statement:\nGiven a main string `text` and a substring `pattern`, find the starting index of the first occurrence of `pattern` within `text`. Return -1 if `pattern` is not found in `text`.\n\n### Examples:\n**Input:** text = \"findthefind\", pattern = \"find\"\n**Output:** 0\n**Explanation:** The substring \"find\" appears starting at index 0 and again at index 7. The first occurrence is at position 0.\n\n**Input:** text = \"programming\", pattern = \"gram\"\n**Output:** 3\n**Explanation:** The substring \"gram\" begins at index 3 in \"programming\".",
        "algorithm": "## Algorithm\n\n### 1. Brute-Force Approach (Naive String Matching)\n\n**Algorithm:**\n\n**Handle Edge Cases:**\n- If `pattern` is empty, return 0 (empty string is trivially found at the start).\n- If `text.length() < pattern.length()`, return -1 (pattern cannot fit).\n\n**Sliding Window Check:**\n- For each possible starting index `i` in `text` from 0 to `text.length() - pattern.length()`:\n  - Compare each character of `pattern` with `text` starting at `i`.\n  - If all characters match, return `i`.\n- If no match is found after all checks, return -1.\n\n---\n\n### 2. Optimal Approach (Knuth-Morris-Pratt (KMP) Algorithm)\n\n**Algorithm:**\n\n**Handle Edge Cases:**\n- Same as brute-force.\n\n**Preprocess Pattern (Compute LPS Array):**\n- Compute the Longest Prefix Suffix (LPS) array for `pattern`:\n  - `lps[i]` = length of the longest proper prefix of `pattern[0..i]` that is also a suffix.\n  - This helps skip unnecessary comparisons during matching.\n\n**Pattern Matching:**\n- Use the LPS array to traverse `text` and `pattern` without backtracking in `text`.\n- If a mismatch occurs, shift `pattern` using LPS to avoid re-checking known matches.",
        "comparison": [
          {
            "algorithm": "Brute-Force",
            "time": "O(m * n)",
            "space": "O(1)"
          },
          {
            "algorithm": "KMP (Optimal)",
            "time": "O(m + n)",
            "space": "O(n)"
          }
        ],
        "analysis": "## Best- and Worst-Case Analysis\n\n### 1. Brute-Force (Naive String Matching)\n\n**Best-Case:**\n- **Scenario:** The pattern is found at the very start of the text (`text[0..n-1] == pattern`).\n- **Example:** `text = \"findthefind\"`, `pattern = \"find\"` → match at `i=0`.\n- **Time Complexity:** O(n) (only n comparisons needed).\n\n**Worst-Case:**\n- **Scenario:** The pattern is not found or appears only at the end after many partial mismatches.\n- **Example:** `text = \"aaaaab\"`, `pattern = \"aab\"` → compares all `m-n+1` positions with near-full pattern checks.\n- **Time Complexity:** O(m × n) (all `m-n+1` starting positions checked, each requiring up to `n` comparisons).\n- **Space Complexity:** Always O(1) (no extra storage beyond loop variables).\n\n---\n\n### 2. Optimal (Knuth-Morris-Pratt / KMP)\n\n**Best-Case:**\n- **Scenario:** The pattern is not found but has no overlapping prefixes/suffixes (e.g., `pattern = \"abcd\"`).\n- **Example:** `text = \"xyz\"`, `pattern = \"abcd\"` → fails in O(m + n) time.\n- **Time Complexity:** O(m + n) (preprocessing O(n) + single pass over text in O(m)).\n\n**Worst-Case:**\n- **Scenario:** The pattern has repeated prefixes/suffixes, but KMP avoids full resets.\n- **Example:** `text = \"aaaaaab\"`, `pattern = \"aaaab\"` → uses LPS to skip redundant checks.\n- **Time Complexity:** O(m + n) (same as best case due to LPS optimization).\n- **Space Complexity:** O(n) (storage for the LPS array).",
        "code": "JAVA CODE:\n\n// BRUTE FORCE:\nclass Solution {\n    public int strStr(String haystack, String needle) {\n        int m = haystack.length();\n        int n = needle.length();\n        \n        if (n == 0) return 0; // Edge case: empty needle\n        if (m < n) return -1; // Needle longer than haystack\n        \n        for (int i = 0; i <= m - n; i++) {\n            int j;\n            for (j = 0; j < n; j++) {\n                if (haystack.charAt(i + j) != needle.charAt(j)) {\n                    break;\n                }\n            }\n            if (j == n) {\n                return i; // Full match found\n            }\n        }\n        return -1;\n    }\n}\n\n\n// OPTIMAL APPROACH (KMP):\nclass Solution {\n    public int strStr(String haystack, String needle) {\n        int m = haystack.length();\n        int n = needle.length();\n        \n        if (n == 0) return 0;\n        if (m < n) return -1;\n        \n        int[] lps = computeLPS(needle);\n        int i = 0, j = 0;\n        while (i < m) {\n            if (haystack.charAt(i) == needle.charAt(j)) {\n                i++;\n                j++;\n                if (j == n) return i - j;\n            } else {\n                if (j != 0) {\n                    j = lps[j - 1];\n                } else {\n                    i++;\n                }\n            }\n        }\n        return -1;\n    }\n    \n    private int[] computeLPS(String needle) {\n        int n = needle.length();\n        int[] lps = new int[n];\n        int len = 0;\n        int i = 1;\n        while (i < n) {\n            if (needle.charAt(i) == needle.charAt(len)) {\n                len++;\n                lps[i] = len;\n                i++;\n            } else {\n                if (len != 0) {\n                    len = lps[len - 1];\n                } else {\n                    lps[i] = 0;\n                    i++;\n                }\n            }\n        }\n        return lps;\n    }\n}\n\n\nC++ CODE:\n\n// BRUTE FORCE:\nclass Solution {\npublic:\n    int strStr(string haystack, string needle) {\n        int m = haystack.size();\n        int n = needle.size();\n\n        if (n == 0) return 0; // Edge case: empty needle\n        if (m < n) return -1; // Needle longer than haystack\n\n        for (int i = 0; i <= m - n; i++) {\n            int j;\n            for (j = 0; j < n; j++) {\n                if (haystack[i + j] != needle[j]) {\n                    break;\n                }\n            }\n            if (j == n) {\n                return i; // Full match found\n            }\n        }\n        return -1;\n    }\n};\n\n\n// OPTIMAL APPROACH (KMP):\nclass Solution {\npublic:\n    int strStr(string haystack, string needle) {\n        int m = haystack.size();\n        int n = needle.size();\n\n        if (n == 0) return 0;\n        if (m < n) return -1;\n\n        vector<int> lps = computeLPS(needle);\n        int i = 0, j = 0;\n        while (i < m) {\n            if (haystack[i] == needle[j]) {\n                i++;\n                j++;\n                if (j == n) return i - j;\n            } else {\n                if (j != 0) {\n                    j = lps[j - 1];\n                } else {\n                    i++;\n                }\n            }\n        }\n        return -1;\n    }\n\nprivate:\n    vector<int> computeLPS(string needle) {\n        int n = needle.size();\n        vector<int> lps(n, 0);\n        int len = 0;\n        int i = 1;\n\n        while (i < n) {\n            if (needle[i] == needle[len]) {\n                len++;\n                lps[i] = len;\n                i++;\n            } else {\n                if (len != 0) {\n                    len = lps[len - 1];\n                } else {\n                    lps[i] = 0;\n                    i++;\n                }\n            }\n        }\n        return lps;\n    }\n};"
      }
    ]
  },
  {
    "topicName": "Matrix",
    "problems": [
      {
        "title": "Rotate a matrix",
        "description": "## Problem Description\n\nGiven an N×N 2D array `grid`, rotate the elements 90 degrees clockwise in-place (without using additional storage space).\n\n### Key Requirements:\n- Must modify the original matrix\n- Rotation must be done layer-by-layer\n- No temporary matrix allocation allowed\n\n\n\n### Example 1:\n\n**Input:**\n```\ngrid = [\n  ['A','B','C'],\n  ['D','E','F'],\n  ['G','H','I']\n]\n```\n**Output:**\n```\n[\n  ['G','D','A'],\n  ['H','E','B'],\n  ['I','F','C']\n]\n```\n\n### Example 2:\n\n**Input:**\n```\ngrid = [\n  [10, 20, 30, 40],\n  [50, 60, 70, 80],\n  [90, 100, 110, 120],\n  [130, 140, 150, 160]\n]\n```\n**Output:**\n```\n[\n  [130, 90, 50, 10],\n  [140, 100, 60, 20],\n  [150, 110, 70, 30],\n  [160, 120, 80, 40]\n]\n```",
        "algorithm": "## Approaches:\n\n### 1. Brute-Force Approach (Using Additional Space)\n\n**Algorithm:**\n- Create a new N×N matrix.\n- For each element at (i, j) in original matrix:\n  - Place it at position (j, N-1-i) in the new matrix.\n- Copy the new matrix back to the original (if required).\n\n---\n\n### 2. Optimal Approach (Layer-by-Layer In-Place Rotation)\n\n**Algorithm:**\n- Process the matrix layer by layer (from outer to inner).\n- For each layer:\n  - Store the top row elements temporarily.\n  - Move elements from left → top.\n  - Move elements from bottom → left.\n  - Move elements from right → bottom.\n  - Move stored top row → right.\n- Repeat this for all layers until reaching the center of the matrix.",
        "comparison": [
          {
            "algorithm": "Brute-Force",
            "time": "O(n^2)",
            "space": "O(n^2)"
          },
          {
            "algorithm": "Optimal",
            "time": "O(n^2)",
            "space": "O(1)"
          }
        ],
        "analysis": "## Best- and Worst-Case Analysis for Both Algorithms\n\n### 1. Brute-Force Approach (Using Additional Space)\n\n**Best-Case Scenario:**\n- Input: Any N x N matrix\n- Behavior: Always creates a new matrix and copies all N² elements\n- Time Complexity: O(N²)\n- Space Complexity: O(N²)\n\n**Worst-Case Scenario:**\n- Input: Any N x N matrix\n- Behavior: Identical to best-case\n- Time Complexity: O(N²)\n- Space Complexity: O(N²)\n\n---\n\n### 2. Optimal Approach (Layer-by-Layer In-Place Rotation)\n\n**Best-Case Scenario:**\n- Input: Any N x N matrix\n- Behavior: Processes each layer, swapping elements in groups of 4\n- Time Complexity: O(N²)\n- Space Complexity: O(1)\n\n**Worst-Case Scenario:**\n- Input: Any N x N matrix\n- Behavior: Identical to best-case\n- Time Complexity: O(N²)\n- Space Complexity: O(1)",
        "code": "JAVA CODE:\n\n// BRUTE FORCE:\nclass Solution {\n    public void rotate(int[][] matrix) {\n        int n = matrix.length;\n        int[][] rotated = new int[n][n];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                rotated[j][n - 1 - i] = matrix[i][j];\n            }\n        }\n        // Copy back to original matrix\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                matrix[i][j] = rotated[i][j];\n            }\n        }\n    }\n}\n\n\n// OPTIMAL APPROACH:\nclass Solution {\n    public void rotate(int[][] matrix) {\n        int n = matrix.length;\n        for (int layer = 0; layer < n / 2; layer++) {\n            int first = layer;\n            int last = n - 1 - layer;\n            for (int i = first; i < last; i++) {\n                int offset = i - first;\n                // Save top\n                int top = matrix[first][i];\n                // Left -> Top\n                matrix[first][i] = matrix[last - offset][first];\n                // Bottom -> Left\n                matrix[last - offset][first] = matrix[last][last - offset];\n                // Right -> Bottom\n                matrix[last][last - offset] = matrix[i][last];\n                // Top -> Right\n                matrix[i][last] = top;\n            }\n        }\n    }\n}\n\n\nC++ CODE:\n\n// BRUTE FORCE:\nclass Solution {\npublic:\n    void rotate(vector<vector<int>>& matrix) {\n        int n = matrix.size();\n        vector<vector<int>> rotated(n, vector<int>(n));\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                rotated[j][n - 1 - i] = matrix[i][j];\n            }\n        }\n        // Copy back to original matrix\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                matrix[i][j] = rotated[i][j];\n            }\n        }\n    }\n};\n\n\n// OPTIMAL APPROACH:\nclass Solution {\npublic:\n    void rotate(vector<vector<int>>& matrix) {\n        int n = matrix.size();\n        for (int layer = 0; layer < n / 2; layer++) {\n            int first = layer;\n            int last = n - 1 - layer;\n            for (int i = first; i < last; i++) {\n                int offset = i - first;\n                // Save top\n                int top = matrix[first][i];\n                // Left -> Top\n                matrix[first][i] = matrix[last - offset][first];\n                // Bottom -> Left\n                matrix[last - offset][first] = matrix[last][last - offset];\n                // Right -> Bottom\n                matrix[last][last - offset] = matrix[i][last];\n                // Top -> Right\n                matrix[i][last] = top;\n            }\n        }\n    }\n};"
      },
      {
        "title": "Spirally traverse a matrix",
        "link": "https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/description/",
        "difficulty": "Medium"
      },
      {
        "title": "Search in a sorted matrix",
        "description": "## Problem Description\n\nGiven a 2D matrix grid of size m×n where:\n- Each row is sorted in ascending order\n- The first element of each row is greater than the last element of the previous row\n\n**Goal:** Determine if a value exists in the matrix.\n\n**Constraints:**\n- Must run in O(log(m*n)) time.\n\n### Matrix Properties:\n- Rows are sorted left-to-right\n- Columns are sorted top-to-bottom (implied by property 2)\n- Entire matrix can be treated as one flattened sorted array\n\n### Example 1:\n**Input:**\ngrid = [\n  [2, 4, 6, 8],\n  [10, 12, 14, 16],\n  [18, 20, 22, 24]\n]\nvalue = 12\n\n**Output:** True\n\n**Explanation:** 12 exists in the second row of the matrix.\n\n### Example 2:\n**Input:**\ngrid = [\n  [5, 10, 15],\n  [25, 30, 35],\n  [45, 50, 55]\n]\nvalue = 40\n\n**Output:** False\n\n**Explanation:** 40 is not present in any row of the matrix.",
        "algorithm": "## 1. Brute-Force Approach (Linear Search)\n\n**Steps:**\n1. Iterate through each row of the matrix.\n2. For each row, iterate through each element.\n3. If the target is found, return True.\n4. If the loop completes without finding the target, return False.\n\n---\n\n## 2. Optimal Approach (Binary Search on Flattened Matrix)\n\n**Steps:**\n1. Initialize `low = 0` and `high = m × n - 1` (indices of the flattened array).\n2. While `low <= high`:\n   - Calculate `mid = low + (high - low) / 2`\n   - Convert `mid` to 2D indices:\n     - `row = mid // n`\n     - `col = mid % n`\n   - Compare `grid[row][col]` with the target:\n     - If equal, return True.\n     - If `grid[row][col] < target`, search the right half (`low = mid + 1`)\n     - Else, search the left half (`high = mid - 1`)\n3. If the loop ends, return False.",
        "comparison": [
          {
            "algorithm": "Brute-Force",
            "time": "O(m × n)",
            "space": "O(1)"
          },
          {
            "algorithm": "Binary Search",
            "time": "O(log(m × n))",
            "space": "O(1)"
          }
        ],
        "analysis": "## Best- and Worst-Case Analysis\n\n### 1. Brute-Force (Linear Search) Approach\n\n**Best-Case Scenario**\n- **Input:** Target is the first element of the matrix\n- **Example:** grid = [[1, 2], [3, 4]], target = 1\n- **Behavior:** Returns immediately after first comparison\n- **Time Complexity:** O(1)\n- **Space Complexity:** O(1)\n\n**Worst-Case Scenario**\n- **Input:** Target is last element or not present\n- **Example:** grid = [[1, 2], [3, 4]], target = 5\n- **Behavior:** Checks every element (m × n comparisons)\n- **Time Complexity:** O(m × n)\n- **Space Complexity:** O(1)\n\n---\n\n### 2. Optimal (Binary Search) Approach\n\n**Best-Case Scenario**\n- **Input:** Target is the middle element\n- **Example:** grid = [[1, 3, 5], [7, 9, 11]], target = 5\n- **Behavior:** Finds target in first comparison\n- **Time Complexity:** O(1)\n- **Space Complexity:** O(1)\n\n**Worst-Case Scenario**\n- **Input:** Target is at either end or not present\n- **Example:** grid = [[1, 3, 5], [7, 9, 11]], target = 12\n- **Behavior:** Performs full binary search (log₂(m × n) comparisons)\n- **Time Complexity:** O(log(m × n))\n- **Space Complexity:** O(1)",
        "code": "JAVA CODE:\n\n// BRUTE FORCE:\nclass Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\n            return false;\n        }\n\n        int m = matrix.length;\n        int n = matrix[0].length;\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (matrix[i][j] == target) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n\n// OPTIMAL APPROACH:\nclass Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\n            return false;\n        }\n\n        int m = matrix.length;\n        int n = matrix[0].length;\n        int left = 0;\n        int right = m * n - 1;\n\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            int midValue = matrix[mid / n][mid % n];\n\n            if (midValue == target) {\n                return true;\n            } else if (midValue < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        return false;\n    }\n}\n\n\nC++ CODE:\n\n// BRUTE FORCE:\nclass Solution {\npublic:\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        if (matrix.empty() || matrix[0].empty()) {\n            return false;\n        }\n\n        int m = matrix.size();\n        int n = matrix[0].size();\n\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (matrix[i][j] == target) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n};\n\n// OPTIMAL APPROACH:\nclass Solution {\npublic:\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        if (matrix.empty() || matrix[0].empty()) {\n            return false;\n        }\n\n        int m = matrix.size();\n        int n = matrix[0].size();\n        int left = 0;\n        int right = m * n - 1;\n\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            int midValue = matrix[mid / n][mid % n];\n\n            if (midValue == target) {\n                return true;\n            } else if (midValue < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        return false;\n    }\n};"
      }
    ]
  },
  {
    "topicName": "Hashing",
    "problems": [
      {
        "title": "Different types of Hashing playlist",
        "link": "https://www.youtube.com/watch?v=W5q0xgxmRd8&list=PLxM5rzx4f4fwOPORqEZZhaaY5OG0WMZfF"
      },
      {
        "title": "Hashing in C++",
        "link": "https://youtu.be/oGqjEx6hrI8?feature=shared"
      },
      {
        "title": "Two Sum",
        "link": "https://leetcode.com/problems/two-sum",
        "difficulty": "Easy"
      },
      {
        "title": "Contains Duplicate",
        "description": "## Problem Description\n\n**Problem Statement:**\nGiven an integer array `elements`, determine if any value appears more than once. Return `true` if duplicates exist, otherwise return `false`.\n\n### Examples:\n\n**Input:** `elements = [5, 8, 2, 5]`\n**Output:** `true`\n**Explanation:** The value `5` appears at both index 0 and index 3.\n\n**Input:** `elements = [10, 20, 30, 40]`\n**Output:** `false`\n**Explanation:** All values in the array are unique.\n\n**Input:** `elements = [7, 7, 7, 7]`\n**Output:** `true`\n**Explanation:** The value `7` appears four times in the array.\n\n### Key Requirements:\n- Must identify if any value is repeated\n- Return boolean result\n- Handle empty arrays (should return false)\n- Efficiently process large arrays",
        "algorithm": "## Approaches:\n\n### 1. Brute-Force Approach (Nested Loops)\n\n**Algorithm:**\n- Loop through the array with index `i` from 0 to n - 1.\n- For each `i`, loop with index `j` from `i + 1` to `n - 1`.\n- If `elements[i] == elements[j]`, return `true` (duplicate found).\n- If loops complete without finding duplicates, return `false`.\n\n---\n\n### 2. Optimal Approach (Using HashSet)\n\n**Algorithm:**\n- Initialize an empty `HashSet` called `seen`.\n- Traverse the array:\n  - If `elements[i]` already exists in `seen`, return `true`.\n  - Else, add `elements[i]` to `seen`.\n- After full traversal, return `false` (no duplicates found).",
        "comparison": [
          {
            "algorithm": "Brute-Force",
            "time": "O(n²)",
            "space": "O(1)"
          },
          {
            "algorithm": "HashSet (Optimal)",
            "time": "O(n)",
            "space": "O(n)"
          }
        ],
        "analysis": "## Best- and Worst-Case Analysis\n\n### 1. Brute-Force Approach (Nested Loops)\n\n**Best-Case Scenario**\n- **Input:** Duplicate appears very early (e.g., `[3, 3, 5, 7]`)\n- **Behavior:** The inner loop finds the duplicate immediately.\n- **Time Complexity:** `O(1)` (early termination)\n- **Space Complexity:** `O(1)`\n\n**Worst-Case Scenario**\n- **Input:** All elements are unique (e.g., `[1, 2, 3, 4, 5]`)\n- **Behavior:** Every pair is compared and no duplicates are found.\n- **Time Complexity:** `O(n²)`\n- **Space Complexity:** `O(1)`\n\n---\n\n### 2. Optimal Approach (HashSet-Based)\n\n**Best-Case Scenario**\n- **Input:** Duplicate found immediately (e.g., `[5, 5, 10, 15]`)\n- **Behavior:** First iteration inserts into set. Second iteration finds duplicate and returns.\n- **Time Complexity:** `O(1)`\n- **Space Complexity:** `O(1)`\n\n**Worst-Case Scenario**\n- **Input:** All elements are unique (e.g., `[10, 20, 30, 40, 50]`)\n- **Behavior:** Each element is added to the set. No duplicates found.\n- **Time Complexity:** `O(n)`\n- **Space Complexity:** `O(n)`"
      },
      {
        "title": "k different pairs",
        "link": "https://leetcode.com/problems/k-diff-pairs-in-an-array/description/",
        "difficulty": "Medium"
      }
    ]
  },
  {
    "topicName": "Linked List",
    "problems": [
      {
        "title": "Create a linked list and perform several operations",
        "details": [
          "a) Insert at the beginning and end.",
          "b) Delete from beginning and end.",
          "c) Search an element in a linked list."
        ]
      },
      {
        "title": "Middle of the linked list",
        "description": "## Problem Description\n\nYou are given the head of a singly linked list. Return the middle node.\n\n- If the list has an **odd number of nodes**, return the exact middle node.\n- If the list has an **even number of nodes**, return the second of the two middle nodes.\n\n### Example 1 (Odd-Length)\n**Input:** `[1, 2, 3, 4, 5]`\n\n**Output:** `[3, 4, 5]`\n\n### Example 2 (Even-Length)\n**Input:** `[1, 2, 3, 4, 5, 6]`\n\n**Output:** `[4, 5, 6]`",
        "algorithm": "## Approaches\n\n### a. Brute Force Approach (Two-Pass)\n\n**Steps:**\n1. **First Pass:** Count the total number of nodes `n`.\n2. **Second Pass:** Traverse to the `n // 2`-th node.\n\n**Implementation:**\n- Initialize `count = 0` and pointer `curr = head`.\n- Traverse to count total nodes.\n- Reset `curr = head`, move it forward `count // 2` times.\n- Return `curr`.\n\n### b. Optimal Approach (Fast and Slow Pointers)\n\n**Steps:**\n1. Initialize `slow = head` and `fast = head`.\n2. Move `slow` one step and `fast` two steps at a time.\n3. When `fast` reaches the end, `slow` is at the middle.\n4. Return `slow`.",
        "analysis": "## Best- and Worst-Case Analysis\n\n### 1. Brute-Force (Two-Pass) Approach\n\n**Best Case:**\n- Input: Empty or single-node list (e.g., `[]` or `[5]`)\n- Early return in O(1) time\n- **Time:** O(1), **Space:** O(1)\n\n**Worst Case:**\n- Input: Large list (e.g., `[1..10⁶]`)\n- First pass counts all nodes, second pass reaches `n/2`\n- **Time:** O(n), **Space:** O(1)\n\n### 2. Optimal (Fast & Slow Pointers) Approach\n\n**Best Case:**\n- Input: Single-node list\n- Fast pointer reaches null quickly\n- **Time:** O(1), **Space:** O(1)\n\n**Worst Case:**\n- Input: Long list (e.g., `[1..10⁶]`)\n- Slow moves `n/2` times while fast traverses all\n- **Time:** O(n), **Space:** O(1)",
        "comparison": [
          {
            "algorithm": "Brute-Force (Two-Pass)",
            "time": "O(n)",
            "space": "O(1)"
          },
          {
            "algorithm": "Fast & Slow Pointers",
            "time": "O(n)",
            "space": "O(1)"
          }
        ],
        "code": "JAVA CODE:\n\n// BRUTE FORCE:\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n        // First pass: count nodes\n        int count = 0;\n        ListNode curr = head;\n        while (curr != null) {\n            count++;\n            curr = curr.next;\n        }\n\n        // Second pass: move to middle\n        curr = head;\n        for (int i = 0; i < count / 2; i++) {\n            curr = curr.next;\n        }\n\n        return curr;\n    }\n}\n\n// OPTIMAL APPROACH:\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n\n        return slow;\n    }\n}\n\n\nC++ CODE:\n\n// BRUTE FORCE:\nclass Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n        // First pass: count nodes\n        int count = 0;\n        ListNode* curr = head;\n        while (curr != nullptr) {\n            count++;\n            curr = curr->next;\n        }\n\n        // Second pass: move to middle\n        curr = head;\n        for (int i = 0; i < count / 2; i++) {\n            curr = curr->next;\n        }\n\n        return curr;\n    }\n};\n\n// OPTIMAL APPROACH:\nclass Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n        ListNode* slow = head;\n        ListNode* fast = head;\n\n        while (fast != nullptr && fast->next != nullptr) {\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n\n        return slow;\n    }\n};"
      },
      {
        "title": "Repeat Task 1 for the doubly linked and circular linked lists"
      },
      {
        "title": "Rotate List",
        "description": "## Problem Description\n\nProblem Statement:\nGiven the starting node ”root” of a singly linked list and an integer “rotations”, rotate the list to the right by “rotations” positions.\n\n### Examples:\n**Input:**\nroot = [10, 20, 30, 40, 50]\nrotations = 3\n\n**Output:** [30, 40, 50, 10, 20]\n\n**Explanation:**\nAfter 1st rotation: [50, 10, 20, 30, 40]\nAfter 2nd rotation: [40, 50, 10, 20, 30]\nAfter 3rd rotation: [30, 40, 50, 10, 20]\n\n**Input:**\nroot = [100, 200, 300]\nrotations = 5\n\n**Output:** [200, 300, 100]\n\n**Explanation:**\nSince list length is 3, 5 rotations is equivalent to 2 rotations (5 % 3 = 2)\nAfter rotation: [200, 300, 100]",
        "algorithm": "## Approaches:\n\n### 1. Brute-Force Approach (Iterative Rotations)\n\n**Algorithm:**\n1. Handle Edge Cases:\n   - If the list is empty or has only one node, return it as-is.\n   - If ‘rotations’ <= 0, return the original list.\n2. Compute Effective Rotations:\n   - Calculate the length of the list (n).\n   - Reduce ‘rotations’ using ‘rotations’ % n (avoids redundant full rotations).\n3. Perform Rotations:\n   - For each rotation:\n     - Traverse to the second-last node.\n     - Move the last node to the front.\n\n---\n\n### 2. Optimal Approach (Two-Pointer Technique)\n\n**Algorithm:**\n1. Handle Edge Cases: Same as brute-force.\n2. Compute Effective Rotations:\n   - Calculate the list length (n).\n   - Reduce ‘rotations’ using ‘rotations’ % n.\n3. Find New Head and Tail:\n   - Use two pointers: ‘fast’ and ‘slow’.\n   - Move ‘fast’ ahead by ‘rotations’ steps.\n   - Move both pointers until ‘fast’ reaches the end.\n   - The new head is ‘slow.next’, and the list is reconnected.",
        "comparison": [
          {
            "algorithm": "Brute-Force",
            "time": "O(n × k)",
            "space": "O(1)"
          },
          {
            "algorithm": "Optimal",
            "time": "O(n)",
            "space": "O(1)"
          }
        ],
        "analysis": "## Best- and Worst-Case Analysis for Both Algorithms\n\n### 1. Brute-Force Approach (Iterative Rotations)\n\n**Best-Case:**\n- **Scenario:** rotations = 0 or rotations % n = 0 (no rotations needed).\n- **Example:** list = [1, 2, 3], rotations = 3.\n- **Time Complexity:** O(n) (only computes length and checks rotations % n).\n\n**Worst-Case:**\n- **Scenario:** rotations = n-1 (maximum effective rotations).\n- **Example:** list = [1, 2, 3, 4, 5], rotations = 4.\n- **Time Complexity:** O(n²) (n rotations × n steps to find tail each time).\n- **Space Complexity:** O(1) (no extra space beyond pointers).\n\n---\n\n### 2. Optimal Approach (Two-Pointer Technique)\n\n**Best-Case:**\n- **Scenario:** rotations = 0 or rotations % n = 0 (early termination).\n- **Example:** list = [10, 20, 30], rotations = 3.\n- **Time Complexity:** O(n) (computes length and exits early).\n\n**Worst-Case:**\n- **Scenario:** rotations = 1 or rotations = n-1 (full pointer traversal required).\n- **Example:** list = [1, 2, 3, 4, 5], rotations = 1.\n- **Time Complexity:** O(n) (two full traversals: length + pointer adjustment).\n- **Space Complexity:** O(1) (uses fixed number of pointers).",
        "code": "JAVA CODE:\n\n// BRUTE FORCE:\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || head.next == null || k == 0) {\n            return head;\n        }\n        // Compute the length of the list\n        int length = 1;\n        ListNode tail = head;\n        while (tail.next != null) {\n            tail = tail.next;\n            length++;\n        }\n        k %= length; // Effective number of rotations\n        if (k == 0) return head;\n        \n        // Perform k rotations\n        for (int i = 0; i < k; i++) {\n            ListNode curr = head;\n            // Find the node before tail\n            while (curr.next != tail) {\n                curr = curr.next;\n            }\n            // Rotate\n            tail.next = head;\n            head = tail;\n            tail = curr;\n            tail.next = null;\n        }\n        return head;\n    }\n}\n\n// OPTIMAL APPROACH:\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || head.next == null || k == 0) {\n            return head;\n        }\n\n        // Compute the length and find the tail\n        int length = 1;\n        ListNode tail = head;\n        while (tail.next != null) {\n            tail = tail.next;\n            length++;\n        }\n\n        k %= length; // Effective number of rotations\n        if (k == 0) return head;\n\n        // Find the new tail (length - k - 1 steps from head)\n        ListNode newTail = head;\n        for (int i = 0; i < length - k - 1; i++) {\n            newTail = newTail.next;\n        }\n\n        // Reconnect the list\n        ListNode newHead = newTail.next;\n        newTail.next = null;\n        tail.next = head;\n        return newHead;\n    }\n}\n\n\nC++ CODE:\n\n// BRUTE FORCE:\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if (!head || !head->next || k == 0) {\n            return head;\n        }\n        \n        // Compute the length of the list\n        int length = 1;\n        ListNode* tail = head;\n        while (tail->next) {\n            tail = tail->next;\n            length++;\n        }\n        k %= length; // Effective number of rotations\n        if (k == 0) return head;\n        \n        // Perform k rotations\n        for (int i = 0; i < k; i++) {\n            ListNode* curr = head;\n            // Find the node before tail\n            while (curr->next != tail) {\n                curr = curr->next;\n            }\n            // Rotate\n            tail->next = head;\n            head = tail;\n            tail = curr;\n            tail->next = nullptr;\n        }\n        return head;\n    }\n};\n\n// OPTIMAL APPROACH:\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if (!head || !head->next || k == 0) {\n            return head;\n        }\n\n        // Compute the length and find the tail\n        int length = 1;\n        ListNode* tail = head;\n        while (tail->next) {\n            tail = tail->next;\n            length++;\n        }\n\n        k %= length; // Effective number of rotations\n        if (k == 0) return head;\n\n        // Find the new tail (length - k - 1 steps from head)\n        ListNode* newTail = head;\n        for (int i = 0; i < length - k - 1; i++) {\n            newTail = newTail->next;\n        }\n\n        // Reconnect the list\n        ListNode* newHead = newTail->next;\n        newTail->next = nullptr;\n        tail->next = head;\n\n        return newHead;\n    }\n};"
      },
      {
        "title": "Reverse Linked List",
        "description": "## Problem Description\n\nGiven the starting node ‘listHead’ of a singly linked list, reverse the order of its nodes and return the new head of the reversed list.\n\n### Examples:\n\n**Input:**\nlistHead = [10, 20, 30, 40, 50]\n\n**Output:** [50, 40, 30, 20, 10]\n\n**Explanation:**\nOriginal: 10 → 20 → 30 → 40 → 50\nReversed: 50 → 40 → 30 → 20 → 10\n\n**Input:**\nlistHead = [5, 8]\n\n**Output:** [8, 5]\n\n**Explanation:**\nOriginal: 5 → 8\nReversed: 8 → 5\n\n**Input:**\nlistHead = []\n\n**Output:** []\n\n**Explanation:**\nEmpty list remains empty after reversal",
        "algorithm": "## Approaches:\n\n### 1. Brute-Force Approach (Using Extra Space)\n\n**Algorithm:**\n1. Traverse the List: Collect all node values into an array.\n2. Reverse the Array: Reverse the order of elements in the array.\n3. Reconstruct the List: Create a new linked list using the reversed array.\n\n**Time Complexity:** O(n) for traversing the list (twice: once to collect values, once to build the reversed list).\n\n**Space Complexity:** O(n) for storing the values.\n\n---\n\n### 2. Optimal Approach (In-Place Reversal)\n\n**Algorithm:**\n1. Initialize Pointers: Use three pointers: ‘prev’, ‘curr’, and ‘next’.\n2. Iterate and Reverse Links:\n   - Store the ‘next’ node (`next = curr.next`).\n   - Reverse the link (`curr.next = prev`).\n   - Move pointers forward (`prev = curr`, `curr = next`).\n3. Update Head: The new head is ‘prev’ when the loop ends.",
        "comparison": [
          {
            "algorithm": "Brute-Force",
            "time": "O(n)",
            "space": "O(n)"
          },
          {
            "algorithm": "Optimal",
            "time": "O(n)",
            "space": "O(1)"
          }
        ],
        "analysis": "## Best- and Worst-Case Analysis\n\n### 1. Brute-Force Approach (Using Extra Space)\n\n**Best-Case:**\n- Scenario: Empty list (head = null).\n- Time Complexity: O(1) (no traversal needed).\n\n**Worst-Case:**\n- Scenario: Non-empty list of length n.\n- Time Complexity: O(n) (dominated by linear passes).\n- Space Complexity: O(n) (stores all node values).\n\n---\n\n### 2. Optimal Approach (In-Place Reversal)\n\n**Best-Case:**\n- Scenario: Empty list or single-node list (head = null or head.next = null).\n- Time Complexity: O(1).\n\n**Worst-Case:**\n- Scenario: List of length n (any non-empty list).\n- Time Complexity: O(n) (one pass through the list).\n- Space Complexity: O(1) (uses fixed pointers).",
        "code": "JAVA CODE:\n\n// BRUTE FORCE:\nimport java.util.*;\n\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        if (head == null) return null;\n\n        // Step 1: Collect values into a list\n        List<Integer> values = new ArrayList<>();\n        ListNode curr = head;\n        while (curr != null) {\n            values.add(curr.val);\n            curr = curr.next;\n        }\n\n        // Step 2: Reverse the list\n        Collections.reverse(values);\n\n        // Step 3: Rebuild the linked list\n        ListNode dummy = new ListNode(0);\n        ListNode newCurr = dummy;\n        for (int val : values) {\n            newCurr.next = new ListNode(val);\n            newCurr = newCurr.next;\n        }\n\n        return dummy.next;\n    }\n}\n\n\n// OPTIMAL APPROACH:\n\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n\n        while (curr != null) {\n            ListNode next = curr.next; // Store next node\n            curr.next = prev;         // Reverse the link\n            prev = curr;              // Move prev forward\n            curr = next;              // Move curr forward\n        }\n\n        return prev; // New head of the reversed list\n    }\n}\n\n\nC++ CODE:\n\n// BRUTE FORCE:\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        if (!head) return nullptr;\n\n        // Step 1: Collect values into a vector\n        vector<int> values;\n        ListNode* curr = head;\n        while (curr) {\n            values.push_back(curr->val);\n            curr = curr->next;\n        }\n\n        // Step 2: Reverse the vector\n        reverse(values.begin(), values.end());\n\n        // Step 3: Rebuild the linked list\n        ListNode* dummy = new ListNode(0);\n        ListNode* newCurr = dummy;\n        for (int val : values) {\n            newCurr->next = new ListNode(val);\n            newCurr = newCurr->next;\n        }\n\n        return dummy->next;\n    }\n};\n\n\n// OPTIMAL APPROACH:\n\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n\n        while (curr) {\n            ListNode* next = curr->next; // Store next node\n            curr->next = prev;           // Reverse the link\n            prev = curr;                 // Move prev forward\n            curr = next;                 // Move curr forward\n        }\n\n        return prev; // New head of the reversed list\n    }\n};"
      },
      {
        "title": "Loop in a list",
        "description": "## Problem Description\n\nGiven the starting node `listHead` of a linked list, determine if the list contains a cycle. A cycle exists if any node's next pointer points to a previously visited node, creating an infinite loop.\n\n### Examples:\n**Input:** listHead = [5, 8, 2, 9] (with node 9 pointing back to node 8)\n**Output:** true\n\n**Input:** listHead = [10, 20] (with node 20 pointing back to node 10)\n**Output:** true\n\n**Input:** listHead = [100] (single node with no cycles)\n**Output:** false",
        "algorithm": "## Algorithm\n\n### 1. Brute-Force Approach (Hash Set Tracking)\n\n**Steps:**\n- Traverse the List:\n  - Use a hash set to store visited nodes.\n  - For each node, check if it exists in the set.\n  - If yes, a cycle exists; if no, add the node to the set.\n- Termination:\n  - If traversal reaches null, no cycle exists.\n\n---\n\n### 2. Optimal Approach (Floyd's Tortoise and Hare)\n\n**Steps:**\n- Two Pointers:\n  - `slow` moves 1 node per step.\n  - `fast` moves 2 nodes per step.\n- Cycle Detection:\n  - If `fast` meets `slow`, a cycle exists.\n  - If `fast` reaches null, no cycle exists.",
        "comparison": [
          {
            "algorithm": "Brute-Force",
            "time": "O(n)",
            "space": "O(n)"
          },
          {
            "algorithm": "Optimal",
            "time": "O(n)",
            "space": "O(1)"
          }
        ],
        "analysis": "## Best- and Worst-Case Analysis\n\n### 1. Brute-Force Approach (Hash Set Tracking)\n\n**Best-Case:**\n- **Scenario:** Cycle at the first node (e.g., 1 → 2 → 3 → 1).\n- **Time Complexity:** O(1)\n\n**Worst-Case:**\n- **Scenario:** No cycle or cycle at the last node (e.g., 1 → 2 → 3 → 4 → 2).\n- **Time Complexity:** O(n)\n- **Space Complexity:** O(n)\n\n---\n\n### 2. Optimal Approach (Floyd's Tortoise and Hare)\n\n**Best-Case:**\n- **Scenario:** No cycle (list length ≤ 1).\n- **Time Complexity:** O(1)\n\n**Worst-Case:**\n- **Scenario:** Cycle exists, and slow/fast meet after maximum iterations (e.g., 1 → 2 → 3 → 4 → 5 → 3).\n- **Time Complexity:** O(n)\n- **Space Complexity:** O(1)",
        "code": "JAVA CODE:\n\n// BRUTE FORCE:\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic class Solution {\n    public boolean hasCycle(ListNode head) {\n        Set<ListNode> visited = new HashSet<>();\n        ListNode current = head;\n        while (current != null) {\n            if (visited.contains(current)) {\n                return true;\n            }\n            visited.add(current);\n            current = current.next;\n        }\n        return false;\n    }\n}\n\n\n// OPTIMAL APPROACH:\npublic class Solution {\n    public boolean hasCycle(ListNode head) {\n        if (head == null || head.next == null) {\n            return false;\n        }\n        ListNode slow = head;\n        ListNode fast = head.next;\n        while (fast != null && fast.next != null) {\n            if (slow == fast) {\n                return true;\n            }\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return false;\n    }\n}\n\n\nC++ CODE:\n\n// BRUTE FORCE:\n#include <unordered_set>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool hasCycle(ListNode *head) {\n        unordered_set<ListNode*> visited;\n        ListNode *current = head;\n        while (current != nullptr) {\n            if (visited.find(current) != visited.end()) {\n                return true;\n            }\n            visited.insert(current);\n            current = current->next;\n        }\n        return false;\n    }\n};\n\n\n// OPTIMAL APPROACH:\nclass Solution {\npublic:\n    bool hasCycle(ListNode *head) {\n        if (head == nullptr || head->next == nullptr) {\n            return false;\n        }\n        ListNode *slow = head;\n        ListNode *fast = head->next;\n        while (fast != nullptr && fast->next != nullptr) {\n            if (slow == fast) {\n                return true;\n            }\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n        return false;\n    }\n};"
      },
      {
        "title": "Intersection of two lists",
        "description": "## Problem Description\n\nGiven the starting nodes `list1` and `list2` of two singly linked lists, determine the node where they intersect (if any). The intersection is defined as a node that appears in both lists with the same memory reference. If no such node exists, return `null`.\n\n### Key Points:\n- The linked lists must maintain their original structure after checking.\n- The solution should handle cases where lists have different lengths.\n- No cycles exist in either list (as per problem constraints).\n\n### Examples:\n\n**1. Input:**\nlist1: A → B → C → D → E\nlist2: F → G → C → D → E\n\n**Output:** Node C\n\n**Explanation:** Both lists converge at node C and share the same subsequent nodes.\n\n**2. Input:**\nlist1: X → Y → Z\nlist2: M → N → O → P\n\n**Output:** null\n\n**Explanation:** The lists never intersect.\n\n**3. Input:**\nlist1: 1 → 2 → 3 → 4\nlist2: 9 → 3 → 4\n\n**Output:** Node 3\n\n**Explanation:** The lists merge at node 3.",
        "algorithm": "## Approaches:\n\n### 1. Brute-Force Approach (Hash Set Tracking)\n\n**Steps:**\n- Traverse `list1` and store all nodes in a hash set.\n- Traverse `list2` and check if any node exists in the hash set.\n- Return the first common node if found.\n- If no match is found, return `null`.\n\n---\n\n### 2. Optimal Approach (Two-Pointer Technique)\n\n**Steps:**\n- Initialize two pointers: `p1` for `list1`, `p2` for `list2`.\n- Move both pointers one step at a time.\n- When either pointer reaches the end, redirect it to the head of the other list.\n- The pointers will either meet at the intersection node or both become null.\n- Return the meeting node or `null` if there's no intersection.",
        "analysis": "## Best- and Worst-Case Analysis\n\n### 1. Brute-Force Approach (Hash Set Tracking)\n\n**Best Case:**\n- Scenario: Intersection at the first node of list2.\n- Time Complexity: O(m)\n- Space Complexity: O(m)\n\n**Worst Case:**\n- Scenario: No intersection or intersection at the last node.\n- Time Complexity: O(m + n)\n- Space Complexity: O(m)\n\n---\n\n### 2. Optimal Approach (Two-Pointer Technique)\n\n**Best Case:**\n- Scenario: Lists are of equal length and intersect immediately.\n- Time Complexity: O(1)\n- Space Complexity: O(1)\n\n**Worst Case:**\n- Scenario: No intersection with maximum length difference.\n- Time Complexity: O(m + n)\n- Space Complexity: O(1)",
        "comparison": [
          {
            "algorithm": "Brute-Force (Hash Set Tracking)",
            "time": "O(m + n)",
            "space": "O(m)"
          },
          {
            "algorithm": "Optimal (Two-Pointer Technique)",
            "time": "O(m + n)",
            "space": "O(1)"
          }
        ],
        "code": "JAVA CODE:\n\n// BRUTE FORCE:\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        Set<ListNode> visited = new HashSet<>();\n\n        // Traverse list A and store all nodes\n        ListNode curr = headA;\n        while (curr != null) {\n            visited.add(curr);\n            curr = curr.next;\n        }\n\n        // Traverse list B to find intersection\n        curr = headB;\n        while (curr != null) {\n            if (visited.contains(curr)) {\n                return curr;\n            }\n            curr = curr.next;\n        }\n        return null;\n    }\n}\n\n\n// OPTIMAL APPROACH:\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode p1 = headA, p2 = headB;\n\n        while (p1 != p2) {\n            // When p1 reaches end, redirect to headB\n            p1 = (p1 == null) ? headB : p1.next;\n            // When p2 reaches end, redirect to headA\n            p2 = (p2 == null) ? headA : p2.next;\n        }\n\n        return p1; // Either intersection node or null\n    }\n}\n\n\nC++ CODE:\n\n// BRUTE FORCE:\n#include <unordered_set>\nusing namespace std;\n\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        unordered_set<ListNode*> visited;\n\n        // Traverse list A and store all nodes\n        ListNode *curr = headA;\n        while (curr != nullptr) {\n            visited.insert(curr);\n            curr = curr->next;\n        }\n\n        // Traverse list B to find intersection\n        curr = headB;\n        while (curr != nullptr) {\n            if (visited.find(curr) != visited.end()) {\n                return curr;\n            }\n            curr = curr->next;\n        }\n        return nullptr;\n    }\n};\n\n\n// OPTIMAL APPROACH:\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode *p1 = headA, *p2 = headB;\n\n        while (p1 != p2) {\n            // When p1 reaches end, redirect to headB\n            p1 = (p1 == nullptr) ? headB : p1->next;\n            // When p2 reaches end, redirect to headA\n            p2 = (p2 == nullptr) ? headA : p2->next;\n        }\n\n        return p1; // Either intersection node or nullptr\n    }\n};"
      },
      {
        "title": "Merge two sorted list",
        "description": "## Problem Description\n\nGiven the starting nodes `sortedListA` and `sortedListB` of two sorted linked lists, merge them into a single sorted linked list by splicing nodes together (without creating new nodes).\n\n**Goal:** Return the head of the merged list.\n\n### Examples:\n\n**Input:**\nsortedListA = [2, 5, 7]\nsortedListB = [3, 6, 8]\n**Output:** [2, 3, 5, 6, 7, 8]\n**Explanation:** Nodes are interleaved in sorted order.\n\n**Input:**\nsortedListA = []\nsortedListB = [10]\n**Output:** [10]\n**Explanation:** Since sortedListA is empty, the result is just sortedListB.\n\n**Input:**\nsortedListA = [100, 200]\nsortedListB = [150, 300]\n**Output:** [100, 150, 200, 300]\n**Explanation:** Merged while maintaining sorted order.\n\n**Input:**\nsortedListA = []\nsortedListB = []\n**Output:** []\n**Explanation:** Both lists are empty, so the result is empty.",
        "algorithm": "## Approaches:\n\n### 1. Brute-Force Approach (Create New List)\n\n**Algorithm:**\n- Initialize a dummy node to build the new merged list.\n- Traverse both lists while comparing their current nodes.\n- Append the smaller node to the new list and move to the next node in that list.\n- Continue until one list is exhausted, then append the remaining nodes from the other list.\n- Return the head of the new merged list.\n\n---\n\n### 2. Optimal Approach (In-Place Merge)\n\n**Algorithm:**\n- Initialize a dummy node to serve as the starting point.\n- Use a tail pointer to track the end of the merged list.\n- Compare nodes from both lists and link the smaller one to the tail.\n- Move the tail and the pointer of the list from which the node was taken.\n- When one list is exhausted, link the remaining nodes of the other list to the tail.\n- Return the head (`dummy.next`) of the merged list.",
        "comparison": [
          {
            "algorithm": "Brute-Force",
            "time": "O(m + n)",
            "space": "O(m + n)"
          },
          {
            "algorithm": "Optimal",
            "time": "O(m + n)",
            "space": "O(1)"
          }
        ],
        "analysis": "## Best- and Worst-Case Analysis\n\n### 1. Brute-Force Approach (Create New List)\n\n**Best-Case:**\n- **Scenario:** One list is empty (e.g., sortedListA = [], sortedListB = [1, 2, 3]).\n- **Time Complexity:** O(1) (early termination).\n- **Space Complexity:** O(n) (copies all nodes of the non-empty list).\n\n**Worst-Case:**\n- **Scenario:** Both lists are non-empty and interleaved (e.g., sortedListA = [1, 3, 5], sortedListB = [2, 4, 6]).\n- **Time Complexity:** O(m + n).\n- **Space Complexity:** O(m + n).\n\n---\n\n### 2. Optimal Approach (In-Place Merge)\n\n**Best-Case:**\n- **Scenario:** One list is empty (e.g., sortedListA = [], sortedListB = [10, 20]).\n- **Time Complexity:** O(1).\n- **Space Complexity:** O(1) (only pointer adjustments).\n\n**Worst-Case:**\n- **Scenario:** Both lists are non-empty and interleaved (e.g., sortedListA = [100, 200], sortedListB = [150, 300]).\n- **Time Complexity:** O(m + n).\n- **Space Complexity:** O(1).",
        "code": "JAVA CODE:\n\n// BRUTE FORCE:\nclass Solution {\n    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {\n        ListNode dummy = new ListNode(0); // Dummy node to build new list\n        ListNode current = dummy;\n        \n        while (list1 != null && list2 != null) {\n            if (list1.val <= list2.val) {\n                current.next = new ListNode(list1.val); // Create new node\n                list1 = list1.next;\n            } else {\n                current.next = new ListNode(list2.val); // Create new node\n                list2 = list2.next;\n            }\n            current = current.next;\n        }\n        \n        // Attach remaining nodes (no new nodes created for remaining elements)\n        current.next = (list1 != null) ? list1 : list2;\n        \n        return dummy.next;\n    }\n}\n\n// OPTIMAL APPROACH:\nclass Solution {\n    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {\n        ListNode dummy = new ListNode(0); // Dummy node to start merged list\n        ListNode tail = dummy;\n        \n        while (list1 != null && list2 != null) {\n            if (list1.val <= list2.val) {\n                tail.next = list1; // Link existing node\n                list1 = list1.next;\n            } else {\n                tail.next = list2; // Link existing node\n                list2 = list2.next;\n            }\n            tail = tail.next;\n        }\n        \n        // Attach remaining nodes directly\n        tail.next = (list1 != null) ? list1 : list2;\n        \n        return dummy.next;\n    }\n}\n\n\nC++ CODE:\n\n// BRUTE FORCE:\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n        ListNode* dummy = new ListNode(0); // Dummy node\n        ListNode* current = dummy;\n        \n        while (list1 && list2) {\n            if (list1->val <= list2->val) {\n                current->next = new ListNode(list1->val); // Create new node\n                list1 = list1->next;\n            } else {\n                current->next = new ListNode(list2->val); // Create new node\n                list2 = list2->next;\n            }\n            current = current->next;\n        }\n        \n        // Attach remaining nodes (no new nodes created)\n        current->next = list1 ? list1 : list2;\n        \n        return dummy->next;\n    }\n};\n\n// OPTIMAL APPROACH:\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n        ListNode* dummy = new ListNode(0); // Dummy node\n        ListNode* tail = dummy;\n        \n        while (list1 && list2) {\n            if (list1->val <= list2->val) {\n                tail->next = list1; // Link existing node\n                list1 = list1->next;\n            } else {\n                tail->next = list2; // Link existing node\n                list2 = list2->next;\n            }\n            tail = tail->next;\n        }\n        \n        // Attach remaining nodes directly\n        tail->next = list1 ? list1 : list2;\n        \n        return dummy->next;\n    }\n};"
      },
      {
        "title": "n-th node from the end",
        "description": "## Problem Description\n\nProblem Statement:\nGiven the starting node linkedList of a singly linked list and an integer n, remove the nth node from the end of the list and return the modified list's head.\n\n### Examples:\n**Input:**\nlinkedList = [10, 20, 30, 40, 50], n = 2\n**Output:** [10, 20, 30, 50]\n**Explanation:** The 2nd node from the end is 40 (node with value 40). After removal, the list becomes [10, 20, 30, 50].\n\n**Input:**\nlinkedList = [5], n = 1\n**Output:** []\n**Explanation:** The 1st node from the end is the only node (5). After removal, the list is empty.\n\n**Input:**\nlinkedList = [100, 200], n = 1\n**Output:** [100]\n**Explanation:** The 1st node from the end is 200. After removal, only 100 remains.",
        "algorithm": "## Algorithm\n\n### 1. Brute-Force Approach (Two-Pass)\n**Algorithm:**\n- **First Pass:** Calculate the length of the linked list.\n- **Compute Position:** Determine the position of the node to remove from the start (length - n).\n- **Second Pass:** Traverse to the node before the target and remove it.\n\n---\n\n### 2. Optimal Approach (One-Pass with Two Pointers)\n**Algorithm:**\n- **Initialize Two Pointers:** fast and slow starting at the head.\n- **Move fast Ahead:** Advance fast by n nodes.\n- **Synchronized Movement:** Move both pointers until fast reaches the end.\n- **Remove Target Node:** slow will be just before the node to remove.",
        "comparison": [
          {
            "algorithm": "Brute-Force",
            "time": "O(L) (two passes)",
            "space": "O(1)"
          },
          {
            "algorithm": "Optimal",
            "time": "O(L) (one pass)",
            "space": "O(1)"
          }
        ],
        "analysis": "## Best- and Worst-Case Analysis for Both Algorithms\n\n### 1. Brute-Force Approach (Two-Pass)\n**Best-Case:**\n- **Scenario:** Removing the head node (when n = length).\n- **Example:** [10,20,30], n=3 → remove 10.\n- **Time Complexity:** O(L) (length calculation dominates).\n- **Space Complexity:** O(1).\n\n**Worst-Case:**\n- **Scenario:** Removing the tail node (when n=1).\n- **Example:** [10,20,30], n=1 → remove 30.\n- **Time Complexity:** O(2L) ≈ O(L).\n- **Space Complexity:** O(1).\n\n---\n\n### 2. Optimal Approach (One-Pass with Two Pointers)\n**Best-Case:**\n- **Scenario:** Removing the head node (when n = length).\n- **Example:** [10,20,30], n=3.\n- **Time Complexity:** O(L) (but often faster in practice).\n- **Space Complexity:** O(1).\n\n**Worst-Case:**\n- **Scenario:** Removing the middle node.\n- **Example:** [10,20,30,40], n=2 → remove 30.\n- **Time Complexity:** O(L) (single pass).\n- **Space Complexity:** O(1).",
        "code": "JAVA CODE:\n\n// BRUTE FORCE:\nclass Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        int length = 0;\n        ListNode curr = head;\n        \n        // First pass: Calculate length\n        while (curr != null) {\n            length++;\n            curr = curr.next;\n        }\n        \n        // Compute position to remove\n        int position = length - n;\n        curr = dummy;\n        \n        // Second pass: Traverse to node before target\n        for (int i = 0; i < position; i++) {\n            curr = curr.next;\n        }\n        \n        // Remove the target node\n        curr.next = curr.next.next;\n        \n        return dummy.next;\n    }\n}\n\n// OPTIMAL APPROACH:\nclass Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode fast = dummy;\n        ListNode slow = dummy;\n        \n        // Move fast ahead by n+1 nodes\n        for (int i = 0; i <= n; i++) {\n            fast = fast.next;\n        }\n        \n        // Move both pointers until fast reaches the end\n        while (fast != null) {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        \n        // Remove the target node\n        slow.next = slow.next.next;\n        \n        return dummy.next;\n    }\n}\n\n\nC++ CODE:\n\n// BRUTE FORCE:\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        ListNode* dummy = new ListNode(0);\n        dummy->next = head;\n        int length = 0;\n        ListNode* curr = head;\n        \n        // First pass: Calculate length\n        while (curr != nullptr) {\n            length++;\n            curr = curr->next;\n        }\n        \n        // Compute position to remove\n        int position = length - n;\n        curr = dummy;\n        \n        // Second pass: Traverse to node before target\n        for (int i = 0; i < position; i++) {\n            curr = curr->next;\n        }\n        \n        // Remove the target node\n        curr->next = curr->next->next;\n        \n        return dummy->next;\n    }\n};\n\n// OPTIMAL APPROACH:\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        ListNode* dummy = new ListNode(0);\n        dummy->next = head;\n        ListNode* fast = dummy;\n        ListNode* slow = dummy;\n        \n        // Move fast ahead by n+1 nodes\n        for (int i = 0; i <= n; i++) {\n            fast = fast->next;\n        }\n        \n        // Move both pointers until fast reaches the end\n        while (fast != nullptr) {\n            fast = fast->next;\n            slow = slow->next;\n        }\n        \n        // Remove the target node\n        slow->next = slow->next->next;\n        \n        return dummy->next;\n    }\n};"
      },
      {
        "title": "Add two numbers",
        "description": "## Problem Description\n\nProblem Statement: Given two non-empty linked lists num1 and num2 representing non-negative integers in reverse digit order (least significant digit first), return their sum as a similarly structured linked list.\n\n**Key Points:**\n- Each node contains a single digit (0-9)\n- Numbers have no leading zeros (except for 0 itself)\n- Result must be in reverse digit order\n- Handle carry-over between digit places\n\n### Examples:\n\n**Input:** num1 = [3, 2, 1] (represents 123), num2 = [6, 5, 4] (represents 456)\n**Output:** [9, 7, 5]\n**Explanation:** 123 + 456 = 579 → reversed as [9, 7, 5]\n\n**Input:** num1 = [5], num2 = [5]\n**Output:** [0, 1]\n**Explanation:** 5 + 5 = 10 → reversed as [0, 1]\n\n**Input:** num1 = [8, 9, 9], num2 = [2]\n**Output:** [0, 0, 0, 1]\n**Explanation:** 998 + 2 = 1000 → reversed as [0, 0, 0, 1]",
        "algorithm": "## Algorithm\n\n### 1. Brute-Force Approach (Convert to Integers)\n\n**Algorithm:**\n- **Convert Each List to an Integer:** Traverse num1 and num2 to reconstruct the original numbers.\n- **Sum the Integers:** Add the two numbers obtained from the linked lists.\n- **Convert Sum Back to Linked List:** Create a new linked list by extracting digits from the sum in reverse order.\n\n### 2. Optimal Approach (Digit-by-Digit Addition with Carry)\n\n**Algorithm:**\n- **Initialize Pointers and Carry:** Use pointers to traverse num1 and num2. Initialize carry to 0.\n- **Digit-by-Digit Addition:** Sum corresponding digits along with carry. Update carry for the next digit place. Store the result digit in a new node.\n- **Handle Remaining Digits or Carry:** Continue until both lists are exhausted. If carry remains, add it as a new node.",
        "comparison": [
          {
            "algorithm": "Brute-Force",
            "time": "O(max(m, n))",
            "space": "O(max(m, n))"
          },
          {
            "algorithm": "Optimal",
            "time": "O(max(m, n))",
            "space": "O(max(m, n))"
          }
        ],
        "analysis": "## Best- and Worst-Case Analysis for Both Algorithms\n\n### 1. Brute-Force Approach (Convert to Integers)\n\n**Best-Case:**\n- **Scenario:** Both lists represent small numbers (e.g., num1 = [1], num2 = [2]).\n- **Time Complexity:** O(1) (constant time for small fixed-size numbers).\n- **Space Complexity:** O(1) (negligible storage).\n\n**Worst-Case:**\n- **Scenario:** Very large numbers (e.g., 100+ digits) causing integer overflow.\n- **Example:** num1 = [9,9,...,9] (100 digits), num2 = [1].\n- **Time Complexity:** Unusable (fails for large inputs).\n- **Space Complexity:** Unusable.\n\n### 2. Optimal Approach (Digit-by-Digit Addition with Carry)\n\n**Best-Case:**\n- **Scenario:** Both lists are short (e.g., num1 = [1], num2 = [2]).\n- **Time Complexity:** O(1) (immediate result).\n- **Space Complexity:** O(1) (minimal nodes created).\n\n**Worst-Case:**\n- **Scenario:** Maximum-length lists with carry propagation (e.g., num1 = [9,9,...,9], num2 = [1]).\n- **Time Complexity:** O(max(m,n)).\n- **Space Complexity:** O(max(m,n)) (stores result digits).",
        "code": "JAVA CODE:\n\n// BRUTE FORCE:\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        // Convert lists to numbers\n        long num1 = listToNumber(l1);\n        long num2 = listToNumber(l2);\n\n        // Add numbers\n        long sum = num1 + num2;\n\n        // Convert sum back to list\n        return numberToList(sum);\n    }\n\n    private long listToNumber(ListNode node) {\n        long num = 0;\n        long place = 1;\n        while (node != null) {\n            num += node.val * place;\n            place *= 10;\n            node = node.next;\n        }\n        return num;\n    }\n\n    private ListNode numberToList(long num) {\n        if (num == 0) return new ListNode(0);\n\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n\n        while (num > 0) {\n            curr.next = new ListNode((int)(num % 10));\n            curr = curr.next;\n            num /= 10;\n        }\n\n        return dummy.next;\n    }\n}\n\n\n// OPTIMAL APPROACH:\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        int carry = 0;\n\n        while (l1 != null || l2 != null || carry != 0) {\n            int x = (l1 != null) ? l1.val : 0;\n            int y = (l2 != null) ? l2.val : 0;\n\n            int sum = x + y + carry;\n            carry = sum / 10;\n\n            curr.next = new ListNode(sum % 10);\n            curr = curr.next;\n\n            if (l1 != null) l1 = l1.next;\n            if (l2 != null) l2 = l2.next;\n        }\n        return dummy.next;\n    }\n}\n\n\nC++ CODE:\n\n// BRUTE FORCE:\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        // Convert lists to numbers\n        long long num1 = listToNumber(l1);\n        long long num2 = listToNumber(l2);\n\n        // Add numbers\n        long long sum = num1 + num2;\n\n        // Convert sum back to list\n        return numberToList(sum);\n    }\n\nprivate:\n    long long listToNumber(ListNode* node) {\n        long long num = 0;\n        long long place = 1;\n        while (node != nullptr) {\n            num += node->val * place;\n            place *= 10;\n            node = node->next;\n        }\n        return num;\n    }\n\n    ListNode* numberToList(long long num) {\n        if (num == 0) return new ListNode(0);\n\n        ListNode* dummy = new ListNode(0);\n        ListNode* curr = dummy;\n\n        while (num > 0) {\n            curr->next = new ListNode(num % 10);\n            curr = curr->next;\n            num /= 10;\n        }\n\n        return dummy->next;\n    }\n};\n\n\n// OPTIMAL APPROACH:\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode* dummy = new ListNode(0);\n        ListNode* curr = dummy;\n        int carry = 0;\n\n        while (l1 != nullptr || l2 != nullptr || carry != 0) {\n            int x = (l1 != nullptr) ? l1->val : 0;\n            int y = (l2 != nullptr) ? l2->val : 0;\n\n            int sum = x + y + carry;\n            carry = sum / 10;\n\n            curr->next = new ListNode(sum % 10);\n            curr = curr->next;\n\n            if (l1 != nullptr) l1 = l1->next;\n            if (l2 != nullptr) l2 = l2->next;\n        }\n\n        return dummy->next;\n    }\n};"
      }
    ]
  }
]
